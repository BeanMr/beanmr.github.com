<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>逗哥的代码作坊</title>
  
  <subtitle>互联网是一门实践性科学</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.beanmr.com/"/>
  <updated>2019-09-09T02:45:54.648Z</updated>
  <id>http://blog.beanmr.com/</id>
  
  <author>
    <name>FengDD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql-manual-8-new-innodb-lock</title>
    <link href="http://blog.beanmr.com/mysql-manual-8-new-innodb-lock/"/>
    <id>http://blog.beanmr.com/mysql-manual-8-new-innodb-lock/</id>
    <published>2019-09-09T02:45:00.000Z</published>
    <updated>2019-09-09T02:45:54.648Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="MySQL" scheme="http://blog.beanmr.com/tags/MySQL/"/>
    
      <category term="InnoDB" scheme="http://blog.beanmr.com/tags/InnoDB/"/>
    
      <category term="Lock" scheme="http://blog.beanmr.com/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记《亿级流量网站架构核心技术》-交易系统设计原则</title>
    <link href="http://blog.beanmr.com/jd-arch-chapter1/"/>
    <id>http://blog.beanmr.com/jd-arch-chapter1/</id>
    <published>2019-08-30T10:43:13.000Z</published>
    <updated>2019-09-03T06:50:12.451Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="思想上的原则"><a href="#思想上的原则" class="headerlink" title="思想上的原则"></a>思想上的原则</h1><h2 id="墨菲定律"><a href="#墨菲定律" class="headerlink" title="墨菲定律"></a>墨菲定律</h2><p>如果事情有变坏的可能，不管这种可能性有多小，它总会发生。</p><p><strong>主要内容：</strong></p><ol><li>任何事都没有表面看起来那么简单；</li><li>所有的事都会比你预计的时间长；</li><li>会出错的事总会出错；</li><li>如果你担心某种情况发生，那么它就更有可能发生。</li></ol><p><strong>实践感悟：</strong></p><p>设计系统时思想上要时刻保持警惕，复杂度低估、工时低估、小概率风险等等</p><h2 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h2><p>设计系统的企业受限于生产设计，这些设计是企业沟通结构的副本——Melvin Conway(1967)。</p><p><strong>主要内容：</strong></p><ol><li>系统架构是公司组织架构的反映</li><li>按照业务闭环进行系统拆分/组织架构划分，实现闭环、高内聚、低耦合，减少沟通成本</li><li>如果沟通出现问题，就应该考虑进行系统或者组织架构的调整</li><li>在合适的实际进行系统拆分，不要一开始就把系统/服务拆分的非常细，虽然闭环，但是每个人负责的系统多、维护成本高。</li></ol><p><strong>扩展阅读：</strong></p><p>参考：《康威定律与微服务》<a href="https://segmentfault.com/a/1190000011118897" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011118897</a></p><p>参考：《阿里中台与组织架构》<a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651018922&amp;idx=1&amp;sn=26ac29a28433ce64f65a7675ddc0b546&amp;chksm=bdbeaef98ac927efce317a5bae726db2c847eab77c8ccffe0f38ea1f246aaa12aa4674d3bff7&amp;mpshare=1&amp;scene=1&amp;srcid=0830eUq2v2oIsq8j0x1V1Kr0&amp;sharer_sharetime=1567160444279&amp;sharer_shareid=206d028041d7f364aa6e82c9398ea525#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651018922&amp;idx=1&amp;sn=26ac29a28433ce64f65a7675ddc0b546&amp;chksm=bdbeaef98ac927efce317a5bae726db2c847eab77c8ccffe0f38ea1f246aaa12aa4674d3bff7&amp;mpshare=1&amp;scene=1&amp;srcid=0830eUq2v2oIsq8j0x1V1Kr0&amp;sharer_sharetime=1567160444279&amp;sharer_shareid=206d028041d7f364aa6e82c9398ea525#rd</a></p><p><strong>实践感悟：</strong></p><p>系统边界的定义往往与组织架构有关；良好的组织架构能提供系统设计的合理性；好的系统慢慢演化的过程中必然会不断的存在系统边界调整或者组织架构的调整。</p><h2 id="二八定律"><a href="#二八定律" class="headerlink" title="二八定律"></a>二八定律</h2><p>人月神话，增加人手可能会进一步的降低效率，故资源的限制约束永远存在。好钢用在刀刃上，以最小化可行产品的方式迭代推进系统演进。</p><h1 id="高并发原则"><a href="#高并发原则" class="headerlink" title="高并发原则"></a>高并发原则</h1><h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>设计无状态的应用，便于水平扩展的应用；依赖分布式架构来应付高并发。</p><p><strong>实践感悟：</strong></p><p>应用无状态就是应用实例不存在本地状态，任何一个请求由任何一个实例处理结果都是一致的。</p><p>简单说，应用不要本地文件系统和内存系统，除非你有分布式方案。</p><p><strong>思考：</strong></p><p>《snowflake算法是有状态的吗？》<a href="https://nicky-chen.github.io/2018/09/19/id-snowflake/" target="_blank" rel="noopener">https://nicky-chen.github.io/2018/09/19/id-snowflake/</a></p><p>《Kafka有状态分布式》<a href="http://kafkadoc.beanmr.com/040_design/01_design_cn.html" target="_blank" rel="noopener">http://kafkadoc.beanmr.com/040_design/01_design_cn.html</a></p><h2 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h2><p>在系统设计初期是做成ALL In One系统还是按功能模块拆分系统需要根据环境权衡。在实际企业级开发中系统的拆分是不可避免，可能是因为系统复杂性、也可能是访问量，另外投入的资源量也是一个重要的考量。</p><p>常见的系统拆分方案有以下几种：</p><ol><li>系统维度拆分：按照系统的功能、业务进行拆分</li><li>功能维度拆分：对一个系统进行功能再拆分，比如优惠系统可以进一步拆分为优惠券、满减、领券等</li><li>读写维度拆分：按照业务的读写特性拆分，比如商品系统的读请求量远远大于写请求量，可以拆分为商品查询服务和商品修改服务，商品查询服务重点在于缓存降低响应时间提高查询效率、写服务核心在审核等管理功能</li><li>按照AOP维度拆分：按照访问特征进行整合，比如页面渲染、CDN管理等</li><li>模块维度拆分：按照基础或者代码维护特性进行拆分，比如数据库连接池、分库分表；代码结构一般按照三层架构</li></ol><h2 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h2><ol><li>首先判断单点的远程服务调用是否可以满足，如果不能满足那么集群是否可以解决？</li><li>考虑在客户端注册多台主机并使用Nginx进行负载均衡是否可行。</li><li>当服务原来越多，可以进一步考虑服务的自动注册与发现。</li><li>进一步随着服务的依赖关系与调用关系越来越复杂，我们应该对服务进行分组与链路梳理。完成服务分层、服务分级、服务隔离，此时还需要考虑限流、黑白名单、降级等；从而进一步提高服务的可靠性提供柔性可降级服务。</li></ol><p>进程内服务&gt;单机RPC&gt;集群PRC&gt;自动注册与发现&gt;服务分级&gt;服务治理框架</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列方案天生就附带了服务解耦（消息体结构接口、一对多消费等）、异步化的特性，依赖消息中间件的堆积能力还能起到削峰填谷的作用，另外依赖消息延迟我们也可以完成事务验证、数据核对。但同时消息队列也会带来事务分割、消息失败（丢失、消费失败）、幂等重试等问题。</p><p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;思想上的原则&quot;&gt;&lt;a href=&quot;#思想上的原则&quot; class=&quot;headerlink&quot; title=&quot;思想上的原则&quot;&gt;&lt;/a&gt;思想上的原则&lt;/h1&gt;&lt;h2 id=&quot;墨菲定律&quot;&gt;&lt;a href=&quot;#墨菲定律&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="Architecture" scheme="http://blog.beanmr.com/tags/Architecture/"/>
    
      <category term="reading-note" scheme="http://blog.beanmr.com/tags/reading-note/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-程序员必读之软件架构</title>
    <link href="http://blog.beanmr.com/reading-note-software-arch-part01/"/>
    <id>http://blog.beanmr.com/reading-note-software-arch-part01/</id>
    <published>2019-05-17T07:08:59.000Z</published>
    <updated>2019-08-30T10:57:12.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于这本书"><a href="#关于这本书" class="headerlink" title="关于这本书"></a>关于这本书</h1><p>《程序员必读之软件架构—Software Architecture for Developers》</p><p>这本书属于图灵程序设计丛书，作者 Simon Brown 译者 邓钢。图书的介绍可以在豆瓣找到 <a href="https://book.douban.com/subject/26248182/。" target="_blank" rel="noopener">https://book.douban.com/subject/26248182/。</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/cover.jpg" alt="cover" title="">                </div>                <div class="image-caption">cover</div>            </figure><p>我读这本书仅仅是因为随手翻阅丛书书单时发现了这本书，图书是否推荐以及推荐理由是什么等着读完再说吧。</p><h1 id="关于架构的探讨"><a href="#关于架构的探讨" class="headerlink" title="关于架构的探讨"></a>关于架构的探讨</h1><p>本章的第一章讨论的核心问题就是什么是软件架构。图书在章节的结尾给出了几个课后习题总结了整章的内容。</p><blockquote><p>(1) 你知道“架构”都说些什么吗?你所在团队的其他人知道吗?你所在组织的其他人呢?</p><p>(2) IT 领域有很多不同类型的架构。它们有什么共同之处?</p><p>(3) 你和团队对“软件架构”的含义有一个标准定义吗?你能够轻松地向团队的新成员解释 吗?这个定义在你所在组织通用吗?</p><p>(4) 如果用“敏捷”来描述一个软件的架构，是什么意思?你如何面向“敏捷”进行设计? </p><p>(5) 你能够把你当前软件项目所做的架构决策列一个清单吗?它们被视为重要的原因明显吗? </p><p>(6) 如果从代码后退一步，你的软件系统的“大局”中包含了哪些事情?</p><p>(7) 你所在组织的技术职业发展怎么样?企业架构会是你的出路吗?</p><p>(8) 软件架构重要吗?为什么，好处是什么?你的软件项目的架构足够吗?还是太多了? </p></blockquote><h2 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于这本书&quot;&gt;&lt;a href=&quot;#关于这本书&quot; class=&quot;headerlink&quot; title=&quot;关于这本书&quot;&gt;&lt;/a&gt;关于这本书&lt;/h1&gt;&lt;p&gt;《程序员必读之软件架构—Software Architecture for Developers》&lt;/p&gt;
&lt;p&gt;这
      
    
    </summary>
    
    
      <category term="architecture,reading-note" scheme="http://blog.beanmr.com/tags/architecture-reading-note/"/>
    
  </entry>
  
  <entry>
    <title>图解Innodb锁子系统</title>
    <link href="http://blog.beanmr.com/2016-8-2-graphic-innodb-lock/"/>
    <id>http://blog.beanmr.com/2016-8-2-graphic-innodb-lock/</id>
    <published>2016-08-01T16:00:00.000Z</published>
    <updated>2019-03-21T06:23:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="InnoDB锁子系统设计目标"><a href="#InnoDB锁子系统设计目标" class="headerlink" title="InnoDB锁子系统设计目标"></a>InnoDB锁子系统设计目标</h2><h2 id="逻辑锁设计及行级锁问题"><a href="#逻辑锁设计及行级锁问题" class="headerlink" title="逻辑锁设计及行级锁问题"></a>逻辑锁设计及行级锁问题</h2><h2 id="Innodb存储模型"><a href="#Innodb存储模型" class="headerlink" title="Innodb存储模型"></a>Innodb存储模型</h2><a id="more"></a><h3 id="数据库文件"><a href="#数据库文件" class="headerlink" title="数据库文件"></a>数据库文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_file_per_table'</span>;</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| innodb_file_per_table | ON    |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="string">`graphic_innodb`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`graphic_innodb`</span>.<span class="string">`db_file_store`</span> (</span><br><span class="line">  <span class="string">`clu_key`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`idx_key`</span> <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`data_col`</span> <span class="built_in">VARCHAR</span>(<span class="number">3800</span>) <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`clu_key`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`se_idx`</span> <span class="keyword">USING</span> BTREE (<span class="string">`idx_key`</span> <span class="keyword">ASC</span>))</span><br><span class="line"><span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = latin1;</span><br></pre></td></tr></table></figure><p>14.11.2 Role of the .frm File for InnoDB Tables</p><p>MySQL stores its data dictionary information for tables in .frm files in database directories. Unlike other MySQL storage engines, InnoDB also encodes information about the table in its own internal data dictionary inside the tablespace. When MySQL drops a table or a database, it deletes one or more .frm files as well as the corresponding entries inside the InnoDB data dictionary. You cannot move InnoDB tables between databases simply by moving the .frm files.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">% python py_innodb_page_info.py -v /usr/local/mysql/data/graphic_innodb/db_file_store.ibd</span><br><span class="line">page offset <span class="number">00000000</span>, page type &lt;File Space Header&gt;</span><br><span class="line">page offset <span class="number">00000001</span>, page type &lt;Insert Buffer Bitmap&gt;</span><br><span class="line">page offset <span class="number">00000002</span>, page type &lt;File Segment inode&gt;</span><br><span class="line">page offset <span class="number">00000003</span>, page type &lt;B-tree Node&gt;, page level &lt;<span class="number">0000</span>&gt;</span><br><span class="line">page offset <span class="number">00000004</span>, page type &lt;B-tree Node&gt;, page level &lt;<span class="number">0000</span>&gt;</span><br><span class="line">page offset <span class="number">00000000</span>, page type &lt;Freshly Allocated Page&gt;</span><br><span class="line">page offset <span class="number">00000000</span>, page type &lt;Freshly Allocated Page&gt;</span><br><span class="line">Total number of page: <span class="number">7</span>:</span><br><span class="line">Freshly Allocated Page: <span class="number">2</span></span><br><span class="line">Insert Buffer Bitmap: <span class="number">1</span></span><br><span class="line">File Space Header: <span class="number">1</span></span><br><span class="line">B-tree Node: <span class="number">2</span></span><br><span class="line">File Segment inode: <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="InnoDB锁子系统关键对象"><a href="#InnoDB锁子系统关键对象" class="headerlink" title="InnoDB锁子系统关键对象"></a>InnoDB锁子系统关键对象</h2><h2 id="InnoDB行级锁对象"><a href="#InnoDB行级锁对象" class="headerlink" title="InnoDB行级锁对象"></a>InnoDB行级锁对象</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;InnoDB锁子系统设计目标&quot;&gt;&lt;a href=&quot;#InnoDB锁子系统设计目标&quot; class=&quot;headerlink&quot; title=&quot;InnoDB锁子系统设计目标&quot;&gt;&lt;/a&gt;InnoDB锁子系统设计目标&lt;/h2&gt;&lt;h2 id=&quot;逻辑锁设计及行级锁问题&quot;&gt;&lt;a href=&quot;#逻辑锁设计及行级锁问题&quot; class=&quot;headerlink&quot; title=&quot;逻辑锁设计及行级锁问题&quot;&gt;&lt;/a&gt;逻辑锁设计及行级锁问题&lt;/h2&gt;&lt;h2 id=&quot;Innodb存储模型&quot;&gt;&lt;a href=&quot;#Innodb存储模型&quot; class=&quot;headerlink&quot; title=&quot;Innodb存储模型&quot;&gt;&lt;/a&gt;Innodb存储模型&lt;/h2&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.beanmr.com/categories/MySQL/"/>
    
    
      <category term="InnoDB" scheme="http://blog.beanmr.com/tags/InnoDB/"/>
    
      <category term="Lock" scheme="http://blog.beanmr.com/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>起底InnoDB锁子系统-事务锁细节解析</title>
    <link href="http://blog.beanmr.com/2016-7-21-innodb-lock-detail/"/>
    <id>http://blog.beanmr.com/2016-7-21-innodb-lock-detail/</id>
    <published>2016-07-20T16:00:00.000Z</published>
    <updated>2019-03-21T04:09:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>当前大多数材料介绍InnoDB锁机制基本都是从锁分析的层面，对于InnoDB加锁的细节并没有过多的披露。比如材料会介绍某个场景InnoDB会对哪些记录加锁、加何种锁；但是没有介绍是如何InnoDB完成的加锁、锁结构是如何的。本文的内容将深入介绍InnoDB的事务锁子系统，将解读InnoDB行级锁为什么性能损耗不是很大、锁实例维护的对象如何组织、加锁过程是如何完成的、锁对象是如何维护的。</p><h2 id="InnoDB的事务锁子系统"><a href="#InnoDB的事务锁子系统" class="headerlink" title="InnoDB的事务锁子系统"></a>InnoDB的事务锁子系统</h2><h2 id="内部锁相关数据结构"><a href="#内部锁相关数据结构" class="headerlink" title="内部锁相关数据结构"></a>内部锁相关数据结构</h2><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="TABLE-LOCK-IS"><a href="#TABLE-LOCK-IS" class="headerlink" title="TABLE LOCK_IS"></a>TABLE LOCK_IS</h3><h3 id="TABLE-LOCK-IX"><a href="#TABLE-LOCK-IX" class="headerlink" title="TABLE LOCK_IX"></a>TABLE LOCK_IX</h3><h3 id="加锁过程分析"><a href="#加锁过程分析" class="headerlink" title="加锁过程分析"></a>加锁过程分析</h3><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><h3 id="行级锁组织结构"><a href="#行级锁组织结构" class="headerlink" title="行级锁组织结构"></a>行级锁组织结构</h3><h3 id="隐式行级锁处理"><a href="#隐式行级锁处理" class="headerlink" title="隐式行级锁处理"></a>隐式行级锁处理</h3><h3 id="显式行级锁处理"><a href="#显式行级锁处理" class="headerlink" title="显式行级锁处理"></a>显式行级锁处理</h3><h4 id="显示S锁"><a href="#显示S锁" class="headerlink" title="显示S锁"></a>显示S锁</h4><h4 id="显式X锁"><a href="#显式X锁" class="headerlink" title="显式X锁"></a>显式X锁</h4><h4 id="GAP锁处理"><a href="#GAP锁处理" class="headerlink" title="GAP锁处理"></a>GAP锁处理</h4><h2 id="锁释放"><a href="#锁释放" class="headerlink" title="锁释放"></a>锁释放</h2><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当前大多数材料介绍InnoDB锁机制基本都是从锁分析的层面，对于InnoDB加锁的细节并没有过多的披露。比如材料会介绍某个场景InnoDB会对哪些记录加锁、加何种锁；但是没有介绍是如何InnoDB完成的加锁、锁结构是如何的。本文的内容将深入介绍InnoDB的事务锁子系统，将
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.beanmr.com/categories/MySQL/"/>
    
    
      <category term="InnoDB" scheme="http://blog.beanmr.com/tags/InnoDB/"/>
    
      <category term="Lock" scheme="http://blog.beanmr.com/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB死锁分析-锁基础理论</title>
    <link href="http://blog.beanmr.com/2016-7-13-innodb-lock/"/>
    <id>http://blog.beanmr.com/2016-7-13-innodb-lock/</id>
    <published>2016-07-12T16:00:00.000Z</published>
    <updated>2019-03-21T06:34:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>死锁是由加锁引起的，要解决死锁首先要明白为什么加锁、加什么样的锁。本篇主要讨论锁相关的一些基础理论以及InnoDB的MVCC特性。</p><h1 id="锁的基础理论"><a href="#锁的基础理论" class="headerlink" title="锁的基础理论"></a>锁的基础理论</h1><h2 id="为什么加锁"><a href="#为什么加锁" class="headerlink" title="为什么加锁"></a>为什么加锁</h2><p>数据库与其它涉及并发的程序一样，都要处理并发的两个关键点<code>互斥</code>和<code>协作</code>；锁就是为了保证互斥特性，让多用户请求可以一致性的读取和修改数据。如果不通过加锁来控制访问的一致性则会造成脏读、幻读、不可重复读等问题。</p><h2 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h2><p>锁就是为了保证某个资源被按照合理的顺序被访问。如果使用一个简单的互斥锁来保护资源，那么当多个读取者访问资源并且期间没有其它的写入者访问，那么每个读取者依旧要依次获取锁资源，但是最终每个读取者获取的还是同一个结果。这样就限制了系统的并发性能，毕竟我们<code>使用锁的原因是希望通过并发来提高系统性能同时依靠锁来解决并发引起的问题</code>。</p><p>如果我们为读写者提供不同的锁，对于被读取者的锁保护的资源允许其它的读取者再加上一把锁并且限制其它的写入者加锁；这样我们就能保证了上述情况下所有的读取者最终获取的结果与之前相同。这样即可以保证系统的安全又可以保证并发的性能，这就是<code>锁模式</code>的一个维度的<code>表现</code>。通常情况下我们将这种锁根据其特性不同分别命名为<code>共享锁 S</code>和<code>排它锁 X</code>。</p><p>如上所述，不同的锁之间有的能“叠加”有的则是互斥的，这就是<code>锁的兼容性</code>。</p><table><thead><tr><th></th><th>S</th><th>X</th></tr></thead><tbody><tr><td>S</td><td>兼容</td><td>不兼容</td></tr><tr><td>X</td><td>不兼容</td><td>不兼容</td></tr></tbody></table><p>众所周知<code>加锁操作需要有构建锁对象，维护锁对象关系等一系列操作，这都会消耗系统性能</code>。假如一个操作者访问某个资源对它进行了加锁操作，但是在它整个操作过程都没有其它人来访问这个资源；如此这个加锁操作的资源消耗就白白浪费了也等于限制了系统的并发性能。那么如果我们在加锁的时候不真正的执行加锁动作，而是在那里<code>贴一个小纸条</code>标示有人来过并且要加锁。这样如果没有其它人来访问此资源则依旧安全并且避免了加锁消耗；如果有人来访问资源其看到这个<code>意向小纸条</code>则为先进去那个人完成加锁操作并且将自己添加到这个锁等待之中，如此依旧保证了系统的安全。这就是<code>锁模式</code>的另外一个维度<code>意向锁</code>。</p><p>综上所述,我们将锁按照不同的模式分为<code>S</code> <code>X</code>两种，同时这两种锁又可以依靠意向标识来表示则为<code>IS</code> <code>IX</code>锁总共4种不同的锁，这就是<a href="https://en.wikipedia.org/wiki/Multiple_granularity_locking" target="_blank" rel="noopener">Multiple granularity locking</a>。</p><p>InnoDB存储引擎支持意向锁设计比较简练；众所周知InnoDB支持行级锁，其意向锁用于表级锁，设计目的主要是为了揭示行级锁的类型。InnoDB支持IS和IX锁两种意向锁：</p><ol><li>IX表示事务想要获得一张表中某几行的排他锁</li><li>IS表示事务想要获得一张表中某几行的共享锁</li></ol><table><thead><tr><th></th><th>IS</th><th>IX</th><th>S</th><th>X</th></tr></thead><tbody><tr><td>IS</td><td>兼容</td><td>兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>兼容</td><td>兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S</td><td>兼容</td><td>不兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr></tbody></table><h2 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h2><p>比如系统的资源是一家里面有很多房子的宾馆，一种加锁方式是当有人入住以后将整个宾馆锁起来，另外一种方式就是锁住入住的房子，这就是锁粒度的划分。</p><p>InnoDB支持行级锁，一般认为行级锁会消耗更多资源，但是实际上InnoDB的实现不需要锁升级，其依赖bitmap实现所以一个锁和多个锁的开销是相同的。</p><h2 id="lock与latch"><a href="#lock与latch" class="headerlink" title="lock与latch"></a>lock与latch</h2><p>最后再讨论一下一个容易混淆的概念lock与latch。</p><p>latch一般称之为闩锁是一种轻量级的锁，latch又可以分为mutex(互斥量)和rwlock(读写锁)。其主要的目的是保证并发线程操作临界资源的正确性。这种锁没有死锁检测机制，所以这里发生了死锁不能被检测出来并恢复处理。<br>lock的对象是事务，用于锁定的是数据库中的对象，比如表、页、行。根据二阶段加锁协议此类lock对象仅仅在commit和rollback后才进行释放。这里是有死锁检测机制的，InnoDB采用<a href="https://en.wikipedia.org/wiki/Wait-for_graph" target="_blank" rel="noopener">Wait-For-Graph</a>算法来实现死锁检测的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-7-13-innodb-lock/1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>InnoDB存储引擎中的Latch可以通过<code>SHOW ENGINE INNODB MUTEX</code>来查看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB MUTEX;</span><br><span class="line">+--------+-------------------+-------------+</span><br><span class="line">| Type   | Name              | Status      |</span><br><span class="line">+--------+-------------------+-------------+</span><br><span class="line">| InnoDB | dict0dict.cc:1057 | os_waits=2  |</span><br><span class="line">| InnoDB | log0log.cc:844    | os_waits=1  |</span><br><span class="line">| InnoDB | fil0fil.cc:1690   | os_waits=1  |</span><br><span class="line">| InnoDB | dict0dict.cc:1066 | os_waits=3  |</span><br><span class="line">| InnoDB | log0log.cc:907    | os_waits=11 |</span><br><span class="line">+--------+-------------------+-------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (4.14 sec)</span><br></pre></td></tr></table></figure></p><p>在Debug模式下<code>SHOW ENGINE INNODB MUTEX</code>能显示更多的信息<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-7-13-innodb-lock/2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>各个字段的描述如下<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-7-13-innodb-lock/3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>相对于latch来看，lock信息就显得直观了。可以通过SHOW ENGINE INNODB STATUS 及information_schema架构下的INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS来观察锁的信息 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;死锁是由加锁引起的，要解决死锁首先要明白为什么加锁、加什么样的锁。本篇主要讨论锁相关的一些基础理论以及InnoDB的MVCC特性。&lt;/p&gt;
&lt;h1 id=&quot;锁的基础理论&quot;&gt;&lt;a href=&quot;#锁的基础理论&quot; class=&quot;headerlink&quot; title=&quot;锁的基础理论&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.beanmr.com/categories/MySQL/"/>
    
    
      <category term="InnoDB" scheme="http://blog.beanmr.com/tags/InnoDB/"/>
    
      <category term="Lock" scheme="http://blog.beanmr.com/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB死锁分析、解决方法论梳理</title>
    <link href="http://blog.beanmr.com/2016-7-13-innodb-deadlock-overview/"/>
    <id>http://blog.beanmr.com/2016-7-13-innodb-deadlock-overview/</id>
    <published>2016-07-12T16:00:00.000Z</published>
    <updated>2019-03-21T06:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中遇到了两个死锁报警，梳理一下关于Innodb死锁相关的知识。主要的内容并不是相关的知识点而是相关知识体系的梳理。最终提供的分析及解决方法论、解决方案也是通用性的提示；本着具体情况具体分析的原则所以这些提示的应用需要相应的知识点进行支撑。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-7-13-innodb-deadlock-overview/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="加锁分析法"><a href="#加锁分析法" class="headerlink" title="加锁分析法"></a>加锁分析法</h1><p>解决死锁首先要了解死锁发生的原因，加锁分析法也就是死锁解决的最基础能力。</p><p>当然进行分析首先需要尽可能的收集各种已知的信息，所以理解Innodb Status、information_schema的innodb表、innodb_status_output日志等内容也就成了必备能力。</p><p>在进行加锁分析的过程中，可能有些细节并不能很好的根据已知的条目进行解释，这时候最好的方法就是看看代码运行过程中实际加了哪些锁。通过代码调试可以更好的了解加锁的细节、印证加锁的猜测，所以代码调试功能可以说是死锁分析法的高级辅助手段。</p><p>当然要想了解每个细节，最终的方法还是阅读源码，但是对于一个非DBA的程序开发人员来说可能没有必要。大多数情况根据已知的InnoDB的加锁原则就能找到问题，也就是根据图片右上、左上两部分的知识点即可以完成。</p><h1 id="解决方案提示"><a href="#解决方案提示" class="headerlink" title="解决方案提示"></a>解决方案提示</h1><p>解决方案主要划分为日常检测、SQL优化、代码级别鲁棒性处理及数据库调整。这些内容都是通用性提示，具体情况具体分析才能找到最优的解决方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在工作中遇到了两个死锁报警，梳理一下关于Innodb死锁相关的知识。主要的内容并不是相关的知识点而是相关知识体系的梳理。最终提供的分析及解决方法论、解决方案也是通用性的提示；本着具体情况具体分析的原则所以这些提示的应用需要相应的知识点进行支撑。&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.beanmr.com/categories/MySQL/"/>
    
    
      <category term="InnoDB" scheme="http://blog.beanmr.com/tags/InnoDB/"/>
    
      <category term="Deadlock" scheme="http://blog.beanmr.com/tags/Deadlock/"/>
    
  </entry>
  
  <entry>
    <title>SublimeText自定义代码片段</title>
    <link href="http://blog.beanmr.com/2016-6-21-sublime-text-snippet/"/>
    <id>http://blog.beanmr.com/2016-6-21-sublime-text-snippet/</id>
    <published>2016-06-20T16:00:00.000Z</published>
    <updated>2019-03-21T06:36:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>写文章或者写代码时常常要输入一些模板型的代码片段。模块代码片段有的已经在IDE中内嵌，但是像下面这种自定义的规则就需要自己定制了。比如下面这个语句就是我自定义的在文章中插入图片的片段；我没有使用固定的路径；我与自己约定，文章的图片存放在<code>/{media_repos}/文章文件名/图片文件</code>位置上。</p>    {% asset_img /1.png %}<p>在SublimeText中自定代码片段的方法如下：</p><ol><li>找到Package文件夹</li><li>进入Package&gt;User&gt;新建文件  文件名为 <code>tag_name.sublime-snippet</code></li><li>文件内容如下，保存并重启Sublime即可<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">snippet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">content</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">![$&#123;2:img&#125;](&#123;&#123; page.path|remove:'_posts/'|remove:'.md'|prepend:site.media_repos|append:'/$&#123;1:1&#125;.png'&#125;&#125; $&#123;3&#125;)</span><br><span class="line">]]&gt;<span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可选: 键入以下内容按Tab触发片段替换 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tabTrigger</span>&gt;</span>postimg<span class="tag">&lt;/<span class="name">tabTrigger</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可选: 在哪类文件中生效 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;scope&gt;source.md&lt;/scope&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snippet</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>自定义代码片段支持变量替换其中<code>${2:img}</code>代表变量替换；其中2代表片段替换后光标定位顺序，img代表此变量默认值。片段替换以后按Tab即可以进行光标依次定位。</p></blockquote><blockquote>{%raw%}标签 使liquid不渲染其内部内容{%endraw%}</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写文章或者写代码时常常要输入一些模板型的代码片段。模块代码片段有的已经在IDE中内嵌，但是像下面这种自定义的规则就需要自己定制了。比如下面这个语句就是我自定义的在文章中插入图片的片段；我没有使用固定的路径；我与自己约定，文章的图片存放在&lt;code&gt;/{media_repos
      
    
    </summary>
    
      <category term="Tools" scheme="http://blog.beanmr.com/categories/Tools/"/>
    
    
      <category term="SublimeText" scheme="http://blog.beanmr.com/tags/SublimeText/"/>
    
  </entry>
  
  <entry>
    <title>[回顾MySQL]体系结构-动态结构</title>
    <link href="http://blog.beanmr.com/2016-6-18-mysql-dynamic-arch/"/>
    <id>http://blog.beanmr.com/2016-6-18-mysql-dynamic-arch/</id>
    <published>2016-06-17T16:00:00.000Z</published>
    <updated>2019-03-21T06:38:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一个章节从静态组成角度分析了MySQL服务器的组成部分；本章节从一个SQL执行的过程分析MySQL各个组件之间的协作和作用。</p><p>简单的说MySQL服务器正常启动以后，开始监听客户端的请求。客户端发送请求与服务器建立连接，之后客户端发送请求、接收返回。</p><h1 id="服务器启动阶段"><a href="#服务器启动阶段" class="headerlink" title="服务器启动阶段"></a>服务器启动阶段</h1><p>系统初始化模块会负责读取配置文件、初始化系统、申请内存创建系统需要的各种Cache、Buffer，这部分属于管理服务及工具组件，系统正常启动以后网络交互模块将监听指定的服务端口等待客户端的连接。</p><h1 id="服务器与客户端建立连接"><a href="#服务器与客户端建立连接" class="headerlink" title="服务器与客户端建立连接"></a>服务器与客户端建立连接</h1><p>网络交互组件负责着监听客户端请求、交互协议处理；MySQL服务器与客户端之间采用<a href="https://dev.mysql.com/doc/internals/en/client-server-protocol.html" target="_blank" rel="noopener">MySQL Client/Server Protocol</a>进行交互，从5.7.12开始支持了新的交互协议<a href="https://dev.mysql.com/doc/internals/en/x-protocol.html" target="_blank" rel="noopener"><code>X Procotol</code></a>这里有一篇<a href="http://mysqlserverteam.com/mysql-5-7-12-part-2-improving-the-mysql-protocol/" target="_blank" rel="noopener">博文</a>对其进行了介绍。</p><p>服务器与客户端之间建立连接的过程就是由这个协议规定的，如下图所示。在建立连接以后在ConnectionPool中就有一个独立的线程与客户端保持联系，并负责初期请求的转发、结果集的包装与发送。</p><blockquote><p>query_slow_log的时间包含网络发送的时间 结果集的大小、发送方式都会影响此数值</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-6-18-mysql-dynamic-arch/connection-phase.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="MySQL-Client-Server-Protocol"><a href="#MySQL-Client-Server-Protocol" class="headerlink" title="MySQL Client/Server Protocol"></a>MySQL Client/Server Protocol</h2><p>协议的设计上支持了以下特性：</p><ol><li>SSL加密传输</li><li>内容压缩传输</li><li>用于交互功能(capabilities)和认证数据的连接阶段</li><li>用于<code>Prepared Statments</code>和存储过程的<a href="https://dev.mysql.com/doc/internals/en/command-phase.html" target="_blank" rel="noopener"><code>command-phase</code></a></li></ol><p>以下组件都是<a href="https://dev.mysql.com/doc/internals/en/client-server-protocol.html" target="_blank" rel="noopener">MySQL Client/Server Protocol</a>的实现，当前它们根据目的不同可能实现的是协议的不同子集：</p><ol><li>Connectors (比如JDBC、ODBC等)</li><li>MySQL Proxy(比如<code>MySQL Proxy</code>/<code>360 Atlas</code>等代理服务机制)</li><li><a href="https://dev.mysql.com/doc/internals/en/replication-protocol.html" target="_blank" rel="noopener">主从复制 Replication Protocol</a></li></ol><p><a href="https://dev.mysql.com/doc/internals/en/client-server-protocol.html" target="_blank" rel="noopener">MySQL Client/Server Protocol</a>有以下协议子集：</p><ol><li>Text Protocol</li><li>Prepared Statements</li><li>Stored Procedures</li><li>Replication Protocol</li><li>Row-Based Replication</li><li>Semi-Synchronous Replication</li></ol><h2 id="Prepared-Statements-Protocol"><a href="#Prepared-Statements-Protocol" class="headerlink" title="Prepared Statements Protocol"></a>Prepared Statements Protocol</h2><p>Prepared Statements Protocol就是处理我们开发中最常用的PreparedStatement的协议。它的核心理念其实就是采用预编译或者参数化的手段来提升需要重复执行的语句总效率，当然还有另外一个选择PreparedStatement的核心理由那就是参数化的模板可以有效的防范SQL注入攻击。</p><p>其一般的工作流程成如下：</p><ol><li>Prepare：应用程序创建Statement模板发送到DBMS，使用占位符来代替具体的数值。</li><li>DBMS对模板进行解析、编译、进行查询优化、执行计划制定等操作，并将结果暂存到服务器中。</li><li>在Client调用Statement的时候，DBMS执行之前的计划并返回结果。</li><li>另外因为语句进行过预编译所以服务器可以提前告知结果集的格式；那么采用Binary方式返回数据可以进一步提高信息熵，减少网络负载提高系统速度。</li></ol><p>但是并不是所有的SQL语句都可以Prepared，这里有个<a href="http://dev.mysql.com/worklog/task/?id=2871" target="_blank" rel="noopener">表格</a>可以浏览一下。</p><h2 id="Text-Protocol"><a href="#Text-Protocol" class="headerlink" title="Text Protocol"></a>Text Protocol</h2><p>相对而言Text Protocol更利于我们学习和分析，从它的定义中我们可以找到如下一系列的命令，这就是在后续CS交互过程中服务器要处理的命令。</p><table><br>    <tr><td><br>        <li>COM_SLEEP</li><br>        <li>COM_QUIT</li><br>        <li>COM_INIT_DB</li><br>        <li>COM_QUERY</li><br>        <li>COM_FIELD_LIST</li><br>        <li>COM_CREATE_DB</li><br>        <li>COM_DROP_DB</li><br>        <li>COM_REFRESH</li><br>        <li>COM_SHUTDOWN</li><br>        <li>COM_STATISTICS</li><br>    </td><td><br>        <li>COM_PROCESS_INFO</li><br>        <li>COM_CONNECT</li><br>        <li>COM_PROCESS_KILL</li><br>        <li>COM_DEBUG</li><br>        <li>COM_PING</li><br>        <li>COM_TIME</li><br>        <li>COM_DELAYED_INSERT</li><br>        <li>COM_CHANGE_USER</li><br>        <li>COM_RESET_CONNECTION</li><br>        <li>COM_DAEMON</li><br>    </td></tr><br></table><h1 id="请求分发"><a href="#请求分发" class="headerlink" title="请求分发"></a>请求分发</h1><p>客户端与服务器建立连接以后，即可以向服务器发送请求。不同的请求类型将会被<code>dispatch_command</code>分发到不同的处理模块进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Perform one connection-level (COM_XXXX) command.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param command         type of command to perform</span></span><br><span class="line"><span class="comment">  @param thd             connection handle</span></span><br><span class="line"><span class="comment">  @param packet          data for the command, packet is always null-terminated</span></span><br><span class="line"><span class="comment">  @param packet_length   length of packet + 1 (to show that data is</span></span><br><span class="line"><span class="comment">                         null-terminated) except for COM_SLEEP, where it</span></span><br><span class="line"><span class="comment">                         can be zero.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @todo</span></span><br><span class="line"><span class="comment">    set thd-&gt;lex-&gt;sql_command to SQLCOM_END here.</span></span><br><span class="line"><span class="comment">  @todo</span></span><br><span class="line"><span class="comment">    The following has to be changed to an 8 byte integer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval</span></span><br><span class="line"><span class="comment">    0   ok</span></span><br><span class="line"><span class="comment">  @retval</span></span><br><span class="line"><span class="comment">    1   request of thread shutdown, i. e. if command is</span></span><br><span class="line"><span class="comment">        COM_QUIT/COM_SHUTDOWN</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dispatch_command</span><span class="params">(<span class="keyword">enum</span> enum_server_command command, THD *thd,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">char</span>* packet, uint packet_length)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> COM_STMT_EXECUTE:</span><br><span class="line">  &#123;</span><br><span class="line">    mysqld_stmt_execute(thd, packet, packet_length);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> COM_STMT_FETCH:</span><br><span class="line">  &#123;</span><br><span class="line">    mysqld_stmt_fetch(thd, packet, packet_length);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> COM_STMT_SEND_LONG_DATA:</span><br><span class="line">  &#123;</span><br><span class="line">    mysql_stmt_get_longdata(thd, packet, packet_length);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> COM_STMT_PREPARE:</span><br><span class="line">  &#123;</span><br><span class="line">    mysqld_stmt_prepare(thd, packet, packet_length);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> COM_STMT_CLOSE:</span><br><span class="line">  &#123;</span><br><span class="line">    mysqld_stmt_close(thd, packet);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请求被分发到对应的处理模块后，返回的结果集合再由连接线程构建成相应的协议返回结果，基础的流程如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-6-18-mysql-dynamic-arch/connection-level-command.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="命令的解析与执行"><a href="#命令的解析与执行" class="headerlink" title="命令的解析与执行"></a>命令的解析与执行</h1><p>在Connection-Level的command_dispath之后，各个命令会到达相应的模块。这些模块会对请求进行解析、之后开始调用各个底层接口方法完成命令。</p><p>另外各个模块收到请求后，首先会通过访问控制模块检查连接用户是否有访问目标表以及目标字段的权限。如果用户拥有相应的权限，那么就会向表管理的模块请求相应的表及对应的锁。</p><p>表管理模块首先会检查表是否打开、是否存在于Table Cache之中；如果表没有被打开则打开相应的表然后继续后续的所操作。当表打开后表管理模块就可以根据表的meta信息，判断表的存储引擎等信息；根据表的存储引擎，命令执行模块就可以将需要的请求提交给存储引擎对应的实例接口进行处理。</p><p>如同上文提到的MySQL的存储引擎插件是基于表层面的，所以对于表变更管理模块来说，可见的仅是存储引擎接口模块所提供的一系列“标准”接口。底层存储引擎实现模块的具体实现，对于表变更管理模块来说是透明的。他只需要调用对应的接口，并指明表类型，接口模块会根据表类型调用正确的存储引擎来进行相应的处理。</p><p>在处理过程中产生的数据库的变化及数据库中数据的变化将会被相应的信息收集服务感知，进而动态的为数据库的运行优化及查询执行计划决策提供数据支持。</p><p>另外为了提升性能数据库还会在这个过程中有大量的优化，比如针对SELECT语句解析器会首先查询Query Cache之中是否已经存在可靠的预编译结果、解析结果、执行结果，如果命中缓存则可以简化相应的步骤。</p><h1 id="其它辅助模块"><a href="#其它辅助模块" class="headerlink" title="其它辅助模块"></a>其它辅助模块</h1><p>相关模块使数据库中的数据发生了变化，而且MySQL 打开了binlog功能，则对应的处理模块还会调用日志处理模块将相应的变更语句以更新事件的形式记录到相关参数指定的二进制日志文件中。在上面各个模块的处理过程中，各自的核心运算处理功能部分都会高度依赖整个MySQL的核心API 模块，比如内存管理，文件I/O，数字和字符串处理等等。</p><p>最后分享网上一个小伙伴的图片</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-6-18-mysql-dynamic-arch/arch-dy.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>本人是一名应用开发工程师并非DBA</p><p>所述内容大多来自对网上小伙伴的分享学习理解 以及MySQL手册</p><p>如果纰漏或者理解有误之处 万望各位小伙伴不吝赐教</p></blockquote><blockquote><p>参考资料：</p><p><a href="https://dev.mysql.com/doc/internals/en/overview.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/overview.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/</a></p><p><a href="http://tigerlchen.iteye.com/blog/1770518" target="_blank" rel="noopener">http://tigerlchen.iteye.com/blog/1770518</a></p><p><a href="http://www.orczhou.com/index.php/tag/mysql/" target="_blank" rel="noopener">http://www.orczhou.com/index.php/tag/mysql/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一个章节从静态组成角度分析了MySQL服务器的组成部分；本章节从一个SQL执行的过程分析MySQL各个组件之间的协作和作用。&lt;/p&gt;
&lt;p&gt;简单的说MySQL服务器正常启动以后，开始监听客户端的请求。客户端发送请求与服务器建立连接，之后客户端发送请求、接收返回。&lt;/p&gt;

      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.beanmr.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.beanmr.com/tags/MySQL/"/>
    
      <category term="Architecture" scheme="http://blog.beanmr.com/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>[回顾MySQL]体系结构-静态组成</title>
    <link href="http://blog.beanmr.com/2016-6-17-mysql-static-arch/"/>
    <id>http://blog.beanmr.com/2016-6-17-mysql-static-arch/</id>
    <published>2016-06-16T16:00:00.000Z</published>
    <updated>2019-03-21T06:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章节主要回顾MySQL数据库的系统结构，梳理MySQL服务器各个组成部分及其功能。</p><h1 id="数据库与数据库实例"><a href="#数据库与数据库实例" class="headerlink" title="数据库与数据库实例"></a>数据库与数据库实例</h1><p>在介绍MySQL的体系结构之前，首先区分一个容易混淆的概念–数据库与数据库实例。大多数情况我们并不强调两者的差别，但作为MySQL与Oracle/SQL Server在结构上的重要区别还是有必要了解的。</p><p>从概念上说数据库是一组按照某种数据模型组织起来的、保存于二级存储中的文件集合；而数据库实例指的是数据库管理程序。对于Oracle来说一个数据库运行于一个数据库实例之中，而MySQL支持单实例多数据库，也就是说我们可以启动一个MySQL程序而在上面创建并运行多个数据库。后续我们将不再强调区分数据库与数据库实例。</p><h1 id="MySQL的静态体系结构"><a href="#MySQL的静态体系结构" class="headerlink" title="MySQL的静态体系结构"></a>MySQL的静态体系结构</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-6-17-mysql-static-arch/mysql-static-arch.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上图来自MySQL官方手册，可以看到MySQL数据库主要由一下几部分组件构成。</p><h2 id="连接池组件"><a href="#连接池组件" class="headerlink" title="连接池组件"></a>连接池组件</h2><p>  主要负责监听发送到MySQL连接请求，对连接进行认证鉴权，然后将请求转发到连接线程、连接线程将负责Server与Client的通信，连接池组件负责管理这些连接线程及线程池，进行线程的创建、销毁、复用以及线程Cache、内存的管理。</p><h2 id="管理服务及工具组件"><a href="#管理服务及工具组件" class="headerlink" title="管理服务及工具组件"></a>管理服务及工具组件</h2><p>  负责着服务器的管理、配置、元数据、备份、恢复、安全功能，复制、集群功能也在这部分实现。</p><h2 id="SQL接口"><a href="#SQL接口" class="headerlink" title="SQL接口"></a>SQL接口</h2><p>  负责处理SQL功能，包括DML、DDL、存储过程、视图、触发器等。SQL语句的含义被转换为对数据库的操作，其中查询语句包含了我们绝多数对数据库的需求，这些查询将被送到查询解析器进行处理，最终生成执行计划，执行并返回我们所需的数据。</p><h2 id="查询分析器组件"><a href="#查询分析器组件" class="headerlink" title="查询分析器组件"></a>查询分析器组件</h2><p>  查询分析器解析SQL查询语句生成MySQL内部的对象，这个过程就是查询翻译的过程；同时在这个过程还有对象权限的校验工作。这部分基本就是一个编译器做的工作，一般基础流程为词法分析、语法分析、最终生成抽象语法树(AST)。词法分析器和语法分析器可以HardCode，但为了简洁可靠人们更多的使用一些已有的组件技术，其中Flex和Bison的组合是最著名的。Flex负责进行词法解析、Bison进行语法分析。但是MySQL为了保证灵活和性能，没有采用Flex而是自己实现了一个分析器；然后用Bison进行语法分析生成MySQL内部的<a href="https://dev.mysql.com/doc/internals/en/item-class.html" target="_blank" rel="noopener"><code>Item对象</code></a>构成AST。有<a href="https://www.safaribooksonline.com/library/view/flex-bison/9780596805418/ch04.html" target="_blank" rel="noopener">一本关于flex/bison的书</a>实例演示了一个SQL词法、语法解析器。作为一个程序人员对这一块理解并不深入，因为它就是负责一个翻译工作，只要保证翻译高效正确即可，而且这个翻译过程非常繁琐、非常艰涩。对于这部分我感觉作为程序人员除了规范SQL格式，尽可能利用查询分析器可能存在的缓存减少、简化翻译过程没有太多可控性。可能DBA或者SQL Proxy会对这一块进行研读，比如<a href="https://github.com/Qihoo360/Atlas" target="_blank" rel="noopener">360 Atlas</a>开发人员。</p><h2 id="优化器组件"><a href="#优化器组件" class="headerlink" title="优化器组件"></a>优化器组件</h2><p>  同一个Query可以按照A路径执行也可以按照B路径执行，不同的执行路径会有不同的执行效率。同时请求到达存储引擎以后使用哪个索引这都严重影响执行的效率。访问路径和索引的选择要依赖对数据的统计所以这部分包含对数据库中的数据情况统计。这一部分是程序人员最需要的关注的，深入理解这部分将能为编写高效程序提供有力的保障。</p><h2 id="缓冲组件"><a href="#缓冲组件" class="headerlink" title="缓冲组件"></a>缓冲组件</h2><p>  缓存是提升效率的一个核心手段，MySQL这个层面的缓存包括全局和引擎级别的缓存的管理。对这一块进行学习理解、尽可能的提高缓存的命中率，将能大大提升系统的性能。</p><h2 id="插件式存储引擎"><a href="#插件式存储引擎" class="headerlink" title="插件式存储引擎"></a>插件式存储引擎</h2><p>  MySQL采用插件式存储引擎是其核心特点之一。不同存储引擎的选择将从根本上影响系统的特性和性能，对比了解各个存储引擎的特性和性能对系统建设是至关重要的。我们最长对比的Myisam和InnoDB引擎，随着时间的发展当前InnoDB基本一手遮天，后续详细梳理也将主要以InnoDB为主。</p><p>  存储引擎负责着自己的内存管理、索引管理和数据的实际存储工作。</p><blockquote><p>MySQL存储引擎是Table层面的</p><p>索引是由存储引擎管理维护的，其存储结构也是存储引擎决定的</p></blockquote><h2 id="物理文件"><a href="#物理文件" class="headerlink" title="物理文件"></a>物理文件</h2><p>  上文提到数据库是指一组按照特定数据模型组织的数据文件集合；这里的组件就是用于管理这些物理文件的，这部分功能基本上依靠存储引擎自己完成的。这部分包含的文件还有Redo、Undo Log，索引，Binary，ERROR、Slow、Query日志等。</p><p>  这些文件的存储根据存储引擎不同可能有不同的差异，但是绝大多数情况还是依赖操作系统的文件系统；因为操作系统可以对数据库屏蔽不同的存储设备的差异，比如NTFS、ext、NAS、SAN等等。当然这也不是一定的，比如InnoDB就支持裸设备存储。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本章节主要回顾MySQL数据库的系统结构，梳理MySQL服务器各个组成部分及其功能。&lt;/p&gt;
&lt;h1 id=&quot;数据库与数据库实例&quot;&gt;&lt;a href=&quot;#数据库与数据库实例&quot; class=&quot;headerlink&quot; title=&quot;数据库与数据库实例&quot;&gt;&lt;/a&gt;数据库与数据库实例
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.beanmr.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.beanmr.com/tags/MySQL/"/>
    
      <category term="Architecture" scheme="http://blog.beanmr.com/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>[回顾MySQL]思维导图</title>
    <link href="http://blog.beanmr.com/2016-6-13-about-mysql-mindmap/"/>
    <id>http://blog.beanmr.com/2016-6-13-about-mysql-mindmap/</id>
    <published>2016-06-12T16:00:00.000Z</published>
    <updated>2019-03-21T06:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>转眼工作好几年了，MySQL一直是主力数据库；现在梳理一下自己MySQL方面的知识汇总成文。本文作为开篇主要是一张思维导图，后续文章将一一展开图中的个个知识点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-6-13-about-mysql-mindmap/mindmap.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h1><h2 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a>结构组成</h2><p>主要介绍MySQL服务器的组成组件和各部分的组件职责。</p><h2 id="动态结构介绍"><a href="#动态结构介绍" class="headerlink" title="动态结构介绍"></a>动态结构介绍</h2><p>查询请求是服务器主要的负载，这部分从一条Query SQL的执行过程介绍各个结构组件的作用及相关关系。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL被设计成插件式体系架构，插件式的存储引擎也是MySQL服务器区别于其它服务器的一个重要特征。本部分将比对介绍各个存储引擎的差异并解析各个对比指标在实际应用的中的意义，最终着重介绍选择InnoDB引擎的几个理由。</p><h2 id="MySQL程序及管理工具"><a href="#MySQL程序及管理工具" class="headerlink" title="MySQL程序及管理工具"></a>MySQL程序及管理工具</h2><p>将介绍MySQL服务器自带的程序及管理工具。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h2><p>本部分主要介绍一个SQL语句上的性能差异。</p><h2 id="库结构优化"><a href="#库结构优化" class="headerlink" title="库结构优化"></a>库结构优化</h2><p>一般的程序员关心语句，好的程序员关心数据结构。一个好的库表结构设计能给性能带来巨大的益处，本部分将介绍一些库表结构上的性能差异。</p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>索引是提升效率的主要途径，一个好的索引能成倍的提高查询性能；但是一个坏的索引也可能给插入更新带来严重的效能消耗。索引基本是程序人员在数据库方面需要最精进的部分，这里会比较详细的介绍对比各种索引的情况，这里主要参照InnoDB引擎的索引进行介绍。</p><blockquote><p>MySQL是插件式的！索引服务是由存储引擎决定的！</p></blockquote><h2 id="针对InnoDB引擎优化"><a href="#针对InnoDB引擎优化" class="headerlink" title="针对InnoDB引擎优化"></a>针对InnoDB引擎优化</h2><p>将介绍一个关于InnoDB引擎的一些优化。</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>MySQL细节的锁管理由存储引擎实现的，锁一直是性能的杀手但是锁又是无法避免的。因为锁的情况受不同的隔离级别、不同的查询条件、MVCC等复杂条件的影响，这部分是非常难以掌握和理解的，这也是MySQL进阶的一个标志。这里将细节的阐述一些锁优化相关的内容，主要还是参考InnoDB引擎来介绍。</p><h2 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h2><p>缓存无处不在在MySQL中也一样，高命中率的缓存将大大提升服务器的查询性能。</p><h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p>一条SQL只要正确执行了就能得到正确的执行结果，但是不同的执行方式却可能有巨大的性能差异。理解MySQL查询优化器，使SQL语句更加契合优化器的习惯，将大大的提升程序性能。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>作为程序员最关注的还是怎么用好MySQL，这部分重要从应用的层面去介绍MySQL。包括了JDBC、连接池、SQL语言、横向扩展MySQL的应用适配内容。</p><h1 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h1><p>这部分将着重讲解一些数据库组成原理的基础学科内容，这将能帮我们更加好的理解MySQL。</p><h1 id="高可用运维"><a href="#高可用运维" class="headerlink" title="高可用运维"></a>高可用运维</h1><p>本人并不专注运维，但是在生产环境中做一些操作并不可以采用简单的SQL完成；这里介绍一些高可用运维发面的内容也是希望抛砖引玉让大家有一些了解<em>工业应用和Demo是有本质区别的</em>。</p><h1 id="面试那些事"><a href="#面试那些事" class="headerlink" title="面试那些事"></a>面试那些事</h1><p>最后和大家聊聊面试中常常遇见的一个问题，毕竟这是大家升职加薪最快的通道之一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转眼工作好几年了，MySQL一直是主力数据库；现在梳理一下自己MySQL方面的知识汇总成文。本文作为开篇主要是一张思维导图，后续文章将一一展开图中的个个知识点。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div c
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.beanmr.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.beanmr.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java工程师要懂的硬件知识-CPU-3-Java与分支预测</title>
    <link href="http://blog.beanmr.com/2016-2-29-a-hardware-view-for-java-cpu-3/"/>
    <id>http://blog.beanmr.com/2016-2-29-a-hardware-view-for-java-cpu-3/</id>
    <published>2016-02-28T16:00:00.000Z</published>
    <updated>2019-03-21T06:40:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将按照从整体到局部的顺序一步步深入介绍现代CPU的结构组成；然后再在CPU简化结构的基础上，根据指令执行的过程一步步的分析CPU的执行阶段，并着重介绍指令流水线、乱序执行和分支预测这些广泛应用的优化技术及这些优化造成的冒险(Hazards)；最后再通过一段Java代码去印证所介绍的内容，去体会Java中的<code>Mechanical Sympathy</code>。</p><h1 id="Java中的分支预测"><a href="#Java中的分支预测" class="headerlink" title="Java中的分支预测"></a>Java中的分支预测</h1><p>本系列之前文章介绍了Java工程师应该了解的CPU相关的一些内容。本文将用一段Java代码去印证、分析上文中介绍的<code>分支预测</code>对Java程序的影响，去体会Java中的<code>Mechanical Sympathy</code>。</p><p>如下代码，准备一个随机数组成的数组作为测试对象，遍历数组并判断如果元素的值大于128则将此元素累加到sum之上。这样的场景在日常开发中非常常见，比如对某一批订单数据需要根据订单的来源和订单的类型的采用不同的流程分支去处理的需求。</p><p>演示程序将分别采用<code>直接遍历</code>，<code>排序后遍历</code>，<code>条件分支语句代替if判断</code>三种方式实现，并在<code>Intel Core i7</code>的<code>Mac OS 10.11.3</code>下采用默认安装的<code>JDK1.8</code>运行。本文将结合之前的内容分析耗时结果，希望各位也在自己的设备上加以验证并在评论中与大家分享自己的结果数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.beanmr.blog.javase.jvm.pipeline;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc:Branch-Prediction In Java Demo</span></span><br><span class="line"><span class="comment"> * ------------------------------------</span></span><br><span class="line"><span class="comment"> * Author:beanmr</span></span><br><span class="line"><span class="comment"> * Date:16/2/20</span></span><br><span class="line"><span class="comment"> * Time:下午11:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BranchPredictionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Generate data</span></span><br><span class="line">        <span class="keyword">int</span> arraySize = <span class="number">32768</span>;</span><br><span class="line">        <span class="keyword">int</span> data[] = <span class="keyword">new</span> <span class="keyword">int</span>[arraySize];</span><br><span class="line"></span><br><span class="line">        Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; arraySize; idx++)</span><br><span class="line">            data[idx] = rnd.nextInt(<span class="number">256</span>);</span><br><span class="line">        <span class="comment">//do Sum without sort</span></span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        doSum(arraySize, data);</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"Sum Without Sort : "</span> + (end - start) / <span class="number">1000000000.0</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">long</span> sortStart = System.nanoTime();</span><br><span class="line">        Arrays.sort(data);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">long</span> sumStart = System.nanoTime();</span><br><span class="line">        doSum(arraySize, data);</span><br><span class="line">        end = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"Sort Cost : "</span> + (sumStart - sortStart) / <span class="number">1000000000.0</span>);</span><br><span class="line">        System.out.println(<span class="string">"Sum Cost : "</span> + (end - sumStart) / <span class="number">1000000000.0</span>);</span><br><span class="line">        System.out.println(<span class="string">"Sort&amp;Sum Cost : "</span> + (end - sortStart) / <span class="number">1000000000.0</span>);</span><br><span class="line">    </span><br><span class="line">        start = System.nanoTime();</span><br><span class="line">        doSumWithConditionalOp(arraySize, data);</span><br><span class="line">        end = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"Sum With ConditionalOp : "</span> + (end - start) / <span class="number">1000000000.0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSum</span><span class="params">(<span class="keyword">int</span> arraySize, <span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;<span class="comment">//amplify loop</span></span><br><span class="line">            <span class="comment">// Primary loop</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; arraySize; ++idx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data[idx] &gt;= <span class="number">128</span>)</span><br><span class="line">                    sum += data[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"sum = "</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSumWithConditionalOp</span><span class="params">(<span class="keyword">int</span> arraySize, <span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;<span class="comment">//amplify loop</span></span><br><span class="line">            <span class="comment">// Primary loop</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; arraySize; ++idx) &#123;</span><br><span class="line">                sum += (data[idx] &gt;= <span class="number">128</span> ? data[idx] : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"sum = "</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="敬请期待以下内容："><a href="#敬请期待以下内容：" class="headerlink" title="敬请期待以下内容："></a>敬请期待以下内容：</h1><h1 id="结果解读"><a href="#结果解读" class="headerlink" title="结果解读"></a>结果解读</h1><h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将按照从整体到局部的顺序一步步深入介绍现代CPU的结构组成；然后再在CPU简化结构的基础上，根据指令执行的过程一步步的分析CPU的执行阶段，并着重介绍指令流水线、乱序执行和分支预测这些广泛应用的优化技术及这些优化造成的冒险(Hazards)；最后再通过一段Java代码去
      
    
    </summary>
    
      <category term="Fundamental" scheme="http://blog.beanmr.com/categories/Fundamental/"/>
    
    
      <category term="Hardware" scheme="http://blog.beanmr.com/tags/Hardware/"/>
    
      <category term="CPU" scheme="http://blog.beanmr.com/tags/CPU/"/>
    
      <category term="Instruction-PipeLine" scheme="http://blog.beanmr.com/tags/Instruction-PipeLine/"/>
    
      <category term="Branch-Prediction" scheme="http://blog.beanmr.com/tags/Branch-Prediction/"/>
    
  </entry>
  
  <entry>
    <title>Java工程师要懂的硬件知识-CPU-2-指令执行</title>
    <link href="http://blog.beanmr.com/2016-2-26-a-hardware-view-for-java-cpu-2/"/>
    <id>http://blog.beanmr.com/2016-2-26-a-hardware-view-for-java-cpu-2/</id>
    <published>2016-02-25T16:00:00.000Z</published>
    <updated>2019-03-21T03:32:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将按照从整体到局部的顺序一步步深入介绍现代CPU的结构组成；然后再在CPU简化结构的基础上，根据指令执行的过程一步步的分析CPU的执行阶段，并着重介绍指令流水线、乱序执行和分支预测这些广泛应用的优化技术及这些优化造成的冒险(Hazards)；最后再通过一段Java代码去印证所介绍的内容，去体会Java中的<code>Mechanical Sympathy</code>。</p><h1 id="敬请期待以下内容："><a href="#敬请期待以下内容：" class="headerlink" title="敬请期待以下内容："></a>敬请期待以下内容：</h1><h1 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h1><h2 id="指令执行与执行阶段"><a href="#指令执行与执行阶段" class="headerlink" title="指令执行与执行阶段"></a>指令执行与执行阶段</h2><h2 id="CPU简化结构"><a href="#CPU简化结构" class="headerlink" title="CPU简化结构"></a>CPU简化结构</h2><h2 id="流水线执行"><a href="#流水线执行" class="headerlink" title="流水线执行"></a>流水线执行</h2><h1 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h1><h1 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h1><h2 id="数据冒险-结构冒险"><a href="#数据冒险-结构冒险" class="headerlink" title="数据冒险/结构冒险"></a>数据冒险/结构冒险</h2><h1 id="Java中的CPU优化"><a href="#Java中的CPU优化" class="headerlink" title="Java中的CPU优化"></a>Java中的CPU优化</h1><h1 id="CPU相关知识分类梳理"><a href="#CPU相关知识分类梳理" class="headerlink" title="CPU相关知识分类梳理"></a>CPU相关知识分类梳理</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将按照从整体到局部的顺序一步步深入介绍现代CPU的结构组成；然后再在CPU简化结构的基础上，根据指令执行的过程一步步的分析CPU的执行阶段，并着重介绍指令流水线、乱序执行和分支预测这些广泛应用的优化技术及这些优化造成的冒险(Hazards)；最后再通过一段Java代码去
      
    
    </summary>
    
      <category term="Fundamental" scheme="http://blog.beanmr.com/categories/Fundamental/"/>
    
    
      <category term="Hardware" scheme="http://blog.beanmr.com/tags/Hardware/"/>
    
      <category term="CPU" scheme="http://blog.beanmr.com/tags/CPU/"/>
    
      <category term="Instruction-PipeLine" scheme="http://blog.beanmr.com/tags/Instruction-PipeLine/"/>
    
      <category term="Out-Of-OrderExecution" scheme="http://blog.beanmr.com/tags/Out-Of-OrderExecution/"/>
    
      <category term="Branch-Prediction" scheme="http://blog.beanmr.com/tags/Branch-Prediction/"/>
    
  </entry>
  
  <entry>
    <title>解决GitHub Pages屏蔽百度爬虫的方法</title>
    <link href="http://blog.beanmr.com/2016-2-24-solve-github-baidu-spider-blocking/"/>
    <id>http://blog.beanmr.com/2016-2-24-solve-github-baidu-spider-blocking/</id>
    <published>2016-02-23T16:00:00.000Z</published>
    <updated>2019-03-21T06:41:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Github屏蔽百度爬虫导致在Github Pages上托管的博客、网站都无法被百度索引到，但对于国内的小伙伴尤其是还在上学的未来的程序员们百度还是一个重要的检索渠道。已经有小伙伴在这方面做了尝试并且进行了全面的分析，这里我仅仅介绍一下个人的做法。这个博客也托管在Github Pages上，个人没有虚拟主机、域名也懒得备案，主要就是通过SAE的免费主机加智能DNS解决的。</p><blockquote><p>新浪云开始征收每天10云豆（一毛钱）的最低租金，此方案不再严格完全免费。</p><p>但充值200元可以在新浪云代办网站备案，之后采用七牛方案也是个不错的选择。</p><p>文章关键点在于智能DNS的应用故保留此文章于此</p></blockquote><h2 id="可行性及原理分析"><a href="#可行性及原理分析" class="headerlink" title="可行性及原理分析"></a>可行性及原理分析</h2><p>已经有小伙伴在这方面做了尝试，<a href="http://jerryzou.com/posts/feasibility-of-allowing-baiduSpider-for-Github-Pages/?utm_source=tuicool" target="_blank" rel="noopener">文章</a>从原理到实践写的很详尽。其主要思路是，希望通过CDN的缓存拦截百度爬虫访问Github服务器，防止百度爬虫到Github服务器被暴揍。但是从CDN的角度，各个厂商还专门发展<code>搜索引擎自动回源</code>所以人家本身就不是准备干这活的。最后小伙伴也采用了个人虚拟主机的方案而且提供了Github的Webhook自动部署实践的介绍。这位叫Jerry的小伙伴棒棒嗒！</p><p>另外也有一部分使用七牛存储的小伙伴，尝试通过在七牛上保存网站的静态文件镜像来服务百度爬虫。主要的优势是七牛的流量和空间很足，只要充值10元就可以绑定自定义域名；但是死穴在于像我这种懒得备案的域名七牛不允许绑定。</p><p>小站最后采用了新浪云主机(SAE)+智能DNS(本人万网)+百度云CDN解决。思路上还是智能DNS针对来自百度解析线路的请求指向SAE服务器，SAE服务器保存Jekyll生成的静态文件当镜像。使用百度CDN的原因并不是为了加速，而是因为百度爬虫机器好像几乎不鸟万网的智能DNS，也就是说万网经常错误返回给百度默认的结果，但所幸对百度CDN的DNS同步做的很好所以加了这个中间层。</p><p>如果万网智能DNS很好用理想的路径如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-2-24-solve-github-baidu-spider-blocking/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>添加了百度CDN以后的路径如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-2-24-solve-github-baidu-spider-blocking/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>有趣的是百度云CDN有两个而且两个都是真的，一个是我用的免费的<a href="http://su.baidu.com/" target="_blank" rel="noopener">百度云加速</a>另一个是百度云CDN。</p><h2 id="操作手册"><a href="#操作手册" class="headerlink" title="操作手册"></a>操作手册</h2><ol><li>注册SAE的账号并创建一个<code>PHP空应用</code>；因为PHP的应用收费最低基本每天几个云豆，点我的连接注册送1000云豆够用好久了，我们只拿它当是一个Nginx服务器用。》》》<a href="http://t.cn/RGKjo3K" target="_blank" rel="noopener">点我注册啊</a>《《《<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-2-24-solve-github-baidu-spider-blocking/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li><p>从应用后台获取代码管理地址，我选用的是git仓库方式。用Github Pages的朋友没有不会的吧，注意因为SAE支持多版本部署所以push的时候要指定。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add sae https://git.sinacloud.com/应用名</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push sae master:1</span><br></pre></td></tr></table></figure></li><li><p><code>jekyll clean</code> <code>jekyll build</code> 拷贝<code>_site</code>到SAE的git然后push</p></li><li>通过SAE的提供的应测试你的站点 http://应用名.applinzi.com/</li><li>到百度云加速添加自己的网站<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-2-24-solve-github-baidu-spider-blocking/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>配置你的DNS服务并测试<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-2-24-solve-github-baidu-spider-blocking/5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>手工同步部分：因为我做了文章和Jekyll源码的分离发布文章总要执行命令所以写了脚本</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Github屏蔽百度爬虫导致在Github Pages上托管的博客、网站都无法被百度索引到，但对于国内的小伙伴尤其是还在上学的未来的程序员们百度还是一个重要的检索渠道。已经有小伙伴在这方面做了尝试并且进行了全面的分析，这里我仅仅介绍一下个人的做法。这个博客也托管在Githu
      
    
    </summary>
    
      <category term="Jekyll" scheme="http://blog.beanmr.com/categories/Jekyll/"/>
    
    
      <category term="github" scheme="http://blog.beanmr.com/tags/github/"/>
    
      <category term="seo" scheme="http://blog.beanmr.com/tags/seo/"/>
    
  </entry>
  
  <entry>
    <title>Java工程师要懂的硬件知识-CPU-1-基础</title>
    <link href="http://blog.beanmr.com/2016-2-20-a-hardware-view-for-java-cpu-1/"/>
    <id>http://blog.beanmr.com/2016-2-20-a-hardware-view-for-java-cpu-1/</id>
    <published>2016-02-19T16:00:00.000Z</published>
    <updated>2019-03-21T06:42:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将按照从整体到局部的顺序一步步深入介绍现代CPU的结构组成；然后再在CPU简化结构的基础上，根据指令执行的过程一步步的分析CPU的执行阶段，并着重介绍指令流水线、乱序执行和分支预测这些广泛应用的优化技术及这些优化造成的冒险(Hazards)；最后再通过一段Java代码去印证所介绍的内容，去体会Java中的<code>Mechanical Sympathy</code>。</p><h1 id="CPU分层架构"><a href="#CPU分层架构" class="headerlink" title="CPU分层架构"></a>CPU分层架构</h1><h2 id="基础硬件知识"><a href="#基础硬件知识" class="headerlink" title="基础硬件知识"></a>基础硬件知识</h2><p>一般认识中的CPU就是主板插槽上那个很多针脚的小方块。对于PC服务器常常会有“2U2路12核24线程”这样的描述，现在参照下面图片中的“戴尔 PowerEdge R730”来解读。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-2-20-a-hardware-view-for-java-cpu-1/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>“2U”指的是这台服务器在机架上占用2个U位置，也就是这台服务器个头有2个单位那么大；“2路”指的是主板上有两个CPU插槽可以插2个CPU实体；“12核”是针对其使用的E5-2620处理器，每颗拥有6个CPU内核，2路也就是12颗内核；另外因为<code>超线程</code>技术所以操作系统中我们可以看到24个CPU逻辑内核也就是24线程。</p><p>更近一步的去观察，去观察硬件的组织结构，如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-2-20-a-hardware-view-for-java-cpu-1/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>图中有两颗CPU每颗CPU上挂载了4条DDR内存条作为各自的主存储，然后两颗CPU之间通过<code>QPI</code>总线连接，这就是<a href="http://blog.beanmr.com/2016/01/14/a-hardware-view-for-java-preface/">上一篇</a>中介绍的NUMA结构的实例。整个结构通过<code>QPI</code>总线与一颗叫做<code>Intel C600</code>的芯片连接，这颗芯片提供着<code>SAS</code>,<code>SATA</code>,<code>PCIe</code>,<code>DMI</code>,<code>USB</code>等IO接口的控制服务。</p><p>再进一步的走到CPU内部就是如下图所示的一片在硅晶上的电路，其实硅晶是面积远小于平时看到的CPU大小。硅晶电路板上的对外连接点会被用导线连接到引脚让，然后用绝缘塑料或者陶瓷进行打包保护，这就是我们常说的封装技术。感兴趣的可以去看一下Intel工厂之旅之类的纪录片有一个感性的理解。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-2-20-a-hardware-view-for-java-cpu-1/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>进一步观察CPU电路板，这颗CPU电路的可以由以下各个组件构成，这些组件在<a href="http://blog.beanmr.com/2016/01/14/a-hardware-view-for-java-preface/">上一篇</a>中都有介绍有兴趣的小伙伴可以回看一下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-2-20-a-hardware-view-for-java-cpu-1/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>最后说一句E5系列的CPU的L3缓存从表面看是一个整体，其实在这次架构设计中Intel加入L3分块的优化设计。原理我们不深究在这里只是提醒一下这个优化的思路是不是跟NUMA有点像。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-2-20-a-hardware-view-for-java-cpu-1/5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="分层结构-指令集-微架构"><a href="#分层结构-指令集-微架构" class="headerlink" title="分层结构/指令集/微架构"></a>分层结构/指令集/微架构</h2><p>重新回归到抽象的CPU世界，CPU体系也不是一个整体结构而是跟我们Java经典三层架构一样是分层。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-2-20-a-hardware-view-for-java-cpu-1/6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>首先最上层是指令集，大的分类有精简指令集(RISC)，比如MIPS、ARM、Power Architecture指令集；复杂指令集CISC，如最经典的x86/x86-64指令集。指令集约定了CPU能完成的一系列的动作，比如ADD加法指令、MOV传送指令等。有了这一些列的指令就支撑起来了一门编程语言也就是常说的汇编语言，因此同样基于x86汇编的程序我们可以运行于Intel的处理器上也可以运行于AMD的处理器上。指令集保证了软件的兼容性，这也就是为什么我国自主知识产权的处理器“龙芯”要去购买MIPS指令集的授权，软硬件系统是一个庞大的生态体系，而指令集就是这个体系中的纽带。</p><p>虽然“龙芯”使用的MIPS指令集，生产也是意法半导体（ST）来代工的；但是我们说它是有自主知识产权的，就是因为它有自己的“GS464E”微架构。微架构就是某个指令架构下的一种实现结构设计，同样的指令集有不同的微架构、每种微架构最终可以有不同的电路实现和电路配置也就有了不同的CPU型号产品。</p><p>指令集-&gt;微架构-&gt;硬件实现，这就是CPU体系的一个分层结构。作为一个Java工程师虽然不必要深入了解每个层次的细节，但是至少要在头脑中有这样的一个体系以便于形成自己的知识体系和问题处理能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将按照从整体到局部的顺序一步步深入介绍现代CPU的结构组成；然后再在CPU简化结构的基础上，根据指令执行的过程一步步的分析CPU的执行阶段，并着重介绍指令流水线、乱序执行和分支预测这些广泛应用的优化技术及这些优化造成的冒险(Hazards)；最后再通过一段Java代码去
      
    
    </summary>
    
      <category term="Fundamental" scheme="http://blog.beanmr.com/categories/Fundamental/"/>
    
    
      <category term="Hardware" scheme="http://blog.beanmr.com/tags/Hardware/"/>
    
      <category term="CPU" scheme="http://blog.beanmr.com/tags/CPU/"/>
    
      <category term="Instruction-PipeLine" scheme="http://blog.beanmr.com/tags/Instruction-PipeLine/"/>
    
      <category term="Out-Of-OrderExecution" scheme="http://blog.beanmr.com/tags/Out-Of-OrderExecution/"/>
    
      <category term="Branch-Prediction" scheme="http://blog.beanmr.com/tags/Branch-Prediction/"/>
    
  </entry>
  
  <entry>
    <title>Java工程师要懂的硬件知识-前言</title>
    <link href="http://blog.beanmr.com/2016-1-14-a-hardware-view-for-java-preface/"/>
    <id>http://blog.beanmr.com/2016-1-14-a-hardware-view-for-java-preface/</id>
    <published>2016-01-13T16:00:00.000Z</published>
    <updated>2019-03-21T06:45:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Mechanical Sympathy</code>这个短语描述了一种车手对汽车天生的感觉，也是<a href="http://mechanical-sympathy.blogspot.sg/" target="_blank" rel="noopener">Martin Thompson大牛的博客</a>标题。从<a href="http://ifeve.com/disruptor-cacheline-padding/" target="_blank" rel="noopener">并发编程网Disruptor</a>的介绍中注意到这个短语，再去品位Martin对它的简短阐述’Hardware and software working together in harmony’的确很有道理。在对任何语言的深入学习研究中，总逃不过对底层硬件的了解与学习，很多语言的特性、行为在硬件的角度去观察就很容易解释了；同时在追求语言的更高性能的过程中，也要更多去了解硬件的知识，让软件更加匹配硬件的特性、更好利用硬件的优化才能获得更高的优化效果。</p><h2 id="概述硬件工程师的杰作"><a href="#概述硬件工程师的杰作" class="headerlink" title="概述硬件工程师的杰作"></a>概述硬件工程师的杰作</h2><p>互联网的繁荣是建立在硬件工程师的伟大杰作之上的。使硬件更加高效的一个途径是提高硬件的运行速度，另外一个途径就是让可以任务并行起来；随之而来的就是缓存、并发、同步等一些列设计和优化。现代计算机的<code>异</code>步特性加之这些优化使得软件系统在多线程的情况下常常出现背离<code>程序直觉</code>的情况。作为一个高级语言开发者了解硬件就是为去感受<code>Mechanical Sympathy</code>，去了解硬件工程师的用心良苦从而让软件与硬件更加匹配。</p><p>讲故事要从开头说，在很早很早以前有一位叫图灵的先生画了一个盒子，这个盒子就一直把人们圈到了现在，这就是图灵机模型。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-1-14-a-hardware-view-for-java-preface/1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个盒子有一条纸带和一个规则表格还有一个内部状态存储，当然还有一个用来读、写纸带的读写头。<strong>整个过程模拟了人类在算草纸进行运算的过程</strong>：在纸上写或擦除一个符号；将注意力从一个位置转移到另外一个位置。</p><p>言归正传虽然现代计算器体系还在这个圈圈之中，但是整体的结构已经变得极度复杂了。<br>下图是一个CPU的<strong>逻辑组成</strong>(物理上并不是都在CPU里)，它作为整个计算机系统的大脑，负责着处理所有类型数据的运算工作(其实还有各式各样的协处理器帮忙)，这也是软件工程师关注的计算机系统核心模型。它主要有<code>CU</code>,<code>MU</code>,<code>ALU</code>,<code>IO</code>四个子系统组成,看似简单的四个框框其实每个都涵盖了N个复杂的结构。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-1-14-a-hardware-view-for-java-preface/cpu.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Memory-Unit"><a href="#Memory-Unit" class="headerlink" title="Memory Unit"></a>Memory Unit</h3><p>简单说<code>内存和存储单元(MU)</code>就是负责保存各种数据的部分，它也称为内部存储/主存储/RAM。RAM的名称来自其硬件特性随机访问，内部存储/主存储的名称来自相对于硬盘等通过IO系统访问的存储而言的。注意这里说的是CPU的<strong>逻辑组成</strong>，<code>MU</code>指的并不仅仅是CPU内部的存储部件还应该涵盖了内存。</p><p><code>MU</code>负责存储的有以下数据：</p><ol><li>处理过程中，所需的所有数据和指令</li><li>处理过程中，产生的中间结果</li><li>已处理完成，但尚未通过输出设备发布的数据</li><li>经输入/输出设备，要进入/输出的所有主内存数据</li></ol><p><code>MU</code>功能看似简单但这一块却是Java工程师最需要关注的部分。众所周知各种存储部件的速度有很大差别，为了匹配高速运行的运算核心并很好的平衡成本，硬件工程师在这里设计了多层的缓存系统。也因为存储系统及IO系统的延迟，为了更好的发挥硬件能力，硬件工程师在这里设计了指令乱序、回写缓冲等等。</p><p>先给出一张Intel的Sandy Bridge微架构处理器的<code>MU</code>示意图，让大家对<code>MU</code>的缓存系统组成和各个部分的访问速度有一个直观的印象。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016-1-14-a-hardware-view-for-java-preface/MemoryHeirarchy.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从图中看到整个<code>MU</code>由每个<strong>核心独享</strong>的<code>寄存器</code>,<code>读取缓冲</code>，<code>存储缓冲</code>,<code>L1 Cache</code>,<code>L2 Cache</code>；<strong>同插槽核心共享</strong>的<code>L3 Cache</code>以及一个跨插槽的<code>NUMA</code>结构组成。<br><code>NUMA</code>是每个<strong>插槽独享</strong>的<code>内存控制器(MC)</code>及<code>MC分配到的内存</code>和连接插槽通信的<code>QPI总线</code>组成的。</p><p>在这些不同核心的缓存之间存在着硬件连线，通过<code>MESI</code>/<code>MESIF</code>/<code>MOESI</code>协议，<code>QPI总线</code>或<code>HT总线</code>保证缓存的一致性。现在网上经常出现对这一块误解的文章，从缓存不一致角度去解释多线程的某些一致性问题；新手要认识到<code>MU</code>的这些缓存在硬件上都已经保证了一致性不要被误导。</p><p>图中标注了每种存储访问的延迟，从最小的1个CPU节拍到跨插槽内存访问时<code>QPI延迟</code>+<code>DRAM访问延迟</code>大致100ns左右的延迟，各级访问速度的差异显而易见。这里的优化一般考虑尽可能命中缓存、降低缓存间一致性协议通信流量的方案。</p><p>直观的看对于一颗频率为3G的CPU核心，因为<code>流水线(Pipeline)</code>技术每CPU节拍可以<a href="注意是并行执行4条指令而不是完成4条指令">并行执行</a>[4条指令][^2]；1ns就有3个节拍也就是每颗核心能并行执行12条指令，可以想象跑一趟主存就可能要耽误1200条指令，而且这个延迟还从10-100纳秒不一定。在等待这个延迟的时候CPU就什么都不做吗？硬件工程师在这里设计了<code>乱序执行</code>，这样就可以很大限度的隐藏这个延迟了。</p><p>由此可见这里对于软件工程师提升性能有多大的发挥空间，软件工程师的<code>Mechanical Sympathy</code>就是在这些细节中展现出的力量。相反这里提到的乱序能很大隐藏延迟，但它也是无数程序员都踩过的深坑，在多线程编程中迷糊了无数人。天下没有免费的午餐！作为一个Java工程师去学习硬件知识可以更好的理解多线程编程、可能大大提升程序的响应速度，但如果平时工作中太纠结于这些硬件细节又会迷失忘却作为一名高级语言开发者最重要的开发效率。</p><h3 id="ALU-Arithmetic-Logic-Unit"><a href="#ALU-Arithmetic-Logic-Unit" class="headerlink" title="ALU(Arithmetic Logic Unit)"></a>ALU(Arithmetic Logic Unit)</h3><p>算数逻辑运算单元(<code>ALU</code>)由算数运算单元(<code>AU</code>)和逻辑运算单元(<code>LU</code>)组成。</p><p>算数运算单元主要完成各种数学运算，也就是加、减、乘、除等运算。在这一块的优化一般就是推荐尽量使用<code>AU</code>擅长的加法、移位运算，比如使用移位运算代替乘法运算、在二维坐标系求两点距离尽量直接使用未开方运算的数值等。</p><p>上述内容在组原教材中有明确的记载大家也很理解和认同。的确在早期的CPU中乘法运算相对加法运算非常耗时，但是随着技术的发展越来越多的CPU整合了数学协处理器，现在差距可能不是那么悬殊了。协处理器就好比CPU的一个小弟，因为其电路是专为某种行为设计的所以在特定操作上比通用处理器速度更快。当CPU遇到某个复杂的运算时会将这个运算交给协处理器完成从而提升整体的速度。这里提到协处理并不是说我们没有必要进行优化了，而是提醒刚刚毕业的小鲜肉们技术日新月异，有的时候我们的教材不一定适用了不要墨守成规，像这样的例子更极端的还有Java(32位JVM测试)里面short运算比int运算更慢。</p><p>逻辑运算单元(<code>LU</code>)就是完成逻辑运算的组件，例如比较、判断、匹配及归并数据(comparing, selecting, matching and merging of data)。</p><h3 id="Control-Unit"><a href="#Control-Unit" class="headerlink" title="Control Unit"></a>Control Unit</h3><p><code>控制单元(CU)</code>负责操作计算机的所有部件协调的工作，它并不直接参与到数据处理、读写过程而是指挥、协调组件完成数据处理。</p><p><code>CU</code>主要完成以下功能：</p><ol><li>控制数据流和指令流在其它系统中的流转</li><li>从<code>MU</code>中获取指令、翻译指令并根据指令操作计算机的完成指令</li><li>控制和协调其它单元的工作</li><li>控制<code>IO</code>单元进行数据的输入输出</li></ol><p>作为一个Java工程师本人对这一块的了解也不是很深入，写在这里也是希望抛砖引玉盼望有朋友能给出一两个这一块优化的实例。</p><h3 id="IO系统"><a href="#IO系统" class="headerlink" title="IO系统"></a>IO系统</h3><p><code>IO系统</code>负责着与外部设备通信，对于Java工程师最常见的就是文件系统访问、数据库访问、网络服务等。这一块延迟相对<code>MU</code>延迟可能是非常大数字，所以作为一个Java工程师这也许是我们使用多线程编程最重要的原因，让程序在IO等待期间并行起来充分利用系统的计算能力。配合多线程还有批量处理、<code>NIO</code>等技术，总之一个应用响应时间出现问题最常见的就是IO占用的时间比非常高而且还是阻塞等待。</p><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>本节非常概括的介绍了CPU基本逻辑组成和一些技术名词；一方面是希望使大家在后续讨论中对这些名词不是很陌生，另外主要的目的还是为新手提供一个参考的概览图，希望在后续讨论过各种局部技术后能为其形成自己的知识体系有一点帮助。</p><p>限于个人技术能力、见识限制，还望各位看官不吝赐教。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.tutorialspoint.com/computer_fundamentals/computer_cpu.htm" target="_blank" rel="noopener">http://www.tutorialspoint.com/computer_fundamentals/computer_cpu.htm</a></p><p><a href="https://www.doc.ic.ac.uk/~wl/teachlocal/arch2/" target="_blank" rel="noopener">https://www.doc.ic.ac.uk/~wl/teachlocal/arch2/</a></p><p><a href="http://ifeve.com/from-javaeye-cpu-cache/" target="_blank" rel="noopener">http://ifeve.com/from-javaeye-cpu-cache/</a></p><p><a href="http://ifeve.com/cpu-cache-flushing-fallacy-cn/" target="_blank" rel="noopener">http://ifeve.com/cpu-cache-flushing-fallacy-cn/</a></p></blockquote><hr><p>[^2]: <strong>4条指令</strong>这个数字是教材数据并不准确实际可能为流水线级数(PipeLine Stage)，Intel早就达到了21级流水线所以这个数字可能大于等于21。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Mechanical Sympathy&lt;/code&gt;这个短语描述了一种车手对汽车天生的感觉，也是&lt;a href=&quot;http://mechanical-sympathy.blogspot.sg/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ma
      
    
    </summary>
    
      <category term="Fundamental" scheme="http://blog.beanmr.com/categories/Fundamental/"/>
    
    
      <category term="Hardware" scheme="http://blog.beanmr.com/tags/Hardware/"/>
    
  </entry>
  
  <entry>
    <title>[工具]如何访问Google-戏说VPN及路由VPN分流</title>
    <link href="http://blog.beanmr.com/2016-1-03-surf-internet-scientifically/"/>
    <id>http://blog.beanmr.com/2016-1-03-surf-internet-scientifically/</id>
    <published>2016-01-02T16:00:00.000Z</published>
    <updated>2019-03-21T06:46:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>估计大多数老外觉着这个命题就如“怎么吸气?”一样无从回答吧！但在咱这儿，这是门手艺！<br>不让访问<code>推</code>，不让访问<code>非死不可</code>都无所谓了；虽然不让用Gmail有点别扭咱也忍啦！但实在受不了熊厂搜索<code>L1 Cache</code>冒出来的结果都是CPU多少钱啊！接着折腾白话一下这个东西是什么，主要是面向完全不懂的小白童靴，已经不纯的请直接跳过。</p><p>如何科学上网这个话题的由来已经烂大街了，但我还是要表达一下我的态度。</p><p>面对现实的说,实际国情的确是很大一部分人民教育水平不高，对信息的判别能力有限容易受到煽动。这一点从微信上每天被转发的各种<a href="https://zh.wikipedia.org/wiki/%E9%BB%84%E8%89%B2%E6%96%B0%E9%97%BB" target="_blank" rel="noopener">黄色新闻</a>(别YY这是个新闻学术语)得到有力的印证。因此有这么一个保护性的监控机制也是非常正当合理的，其实各个国家都有这样的玩意甚至某些国家做的更先进更NB。我觉着人们的坏情绪并不应该是因为有这个玩意，而是因为这个玩意背后的简单粗暴的逻辑。希望以后这个玩意能更细腻更人性化。</p><blockquote><p>科学上网是为了学习交流，要对知识交流饱含好奇心。</p><p>但更要把握好自己的好奇心，防止被用心险恶之人利用。</p></blockquote><p>科学上网比较舒服的方式就是花点钱弄个VPN这是大家的共识，我觉着为了学习花点钱还是值得的。</p><p>VPN这个东西的原理就好比，你住在男生宿舍楼在门口有宿舍管理员大妈，你想和外面的朋友传递消息都要经过这个大妈。有的楼大妈比较温和，她记录下你说的每一句话干的每一件事，万一出了问题再拿着这一堆证据找你喝茶。而我们门口这个大妈可能是脾气暴躁一点，她可能认为任何与某些女生宿舍楼交流的情况都是鸡鸣狗盗、私通羞羞。这个打击面就有点大，这误伤了我们和某些同学之间纯洁的学习交流之需，所以我们才需要学习科学上网。正常情况我们和大妈说的是同一种语言，这个时候大妈就知道你想交流的这个人（可能是不太听大妈的话或者过去的罪过大妈）在她的印象中是坏孩子；但是如果我们在外面有一个卧底（大妈并没有关注她），她和你约定了一种大妈听不懂的暗号（加密），等暗号到了她那再由她翻译并转交给你目标对象，这样我们就可以无阻碍的交流了！VPN就是这样一个交流的通道和交流的方式。</p><p>所以我们的VPN需要在外面有个接应的同志，这个接应的同志一般可以选择直接购买别人搭建好的情报网络使用权，也可以自己在外面建立一个据点培养一个自己的同志。前一种就是直接购买VPN账号，后一种就是租借外面的主机自己搭建VPN服务器。如果自己在外面还有博客、应用一类的需求可以考虑购买一个VPS自建，否则的话我觉着租借别人比较专业的情报网络比较合适。</p><p>等你和外面的卧底建立了联系，接下来的问题就是这个文章的重点了。你除了和外面的世界沟通，更多的时候是和身边的人沟通，但是默认情况下有了VPN所有的流量都会从她那里走。这就好比如你在女生宿舍安插了一个卧底想方便和女性朋友沟通；但实际情况却变成了说的每一句话都要变成密码，先走到女生宿舍卧底那里然后再转达出去；这样就严重影响了你和下铺兄弟沟通的速度，更不爽的是跟卧底说话是要按流量收钱的。</p><p>为了解决这个问题我们可以使用一个叫路由表的东西，这个东西在计算机收到你想交流的需求的时候，可以先去查一下你要交流的对象是在女生宿舍楼还是你下铺，然后再决定是否通过你的卧底。这样不就可以加速又省钱了嘛！当然网上也已经有人做了工具<a href="https://github.com/fivesheep/chnroutes" target="_blank" rel="noopener">chnroutes</a>,它的原理就是先从一个<a href="http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest" target="_blank" rel="noopener">地方</a>弄到所有你可能沟通的对象的房间号，然后在你真正去交流之前先查一下你要的对象是在男生宿舍楼还是女生宿舍楼，如果在男生宿舍楼就不走卧底这条线了。从而实现了即节省VPN流量费又加速了内部访问的效果。</p><p>仅仅是戏说，举个例子让大家方便理解，不严谨不科学还请大家斧正。</p><p>因为VPN供应商鱼龙混杂而且有很多伪造云梯的钓鱼网站，有需要的可以通过我的<a href="http://beatfw.com/?r=ed568f793c226f26" target="_blank" rel="noopener">推荐链接</a>购买，不用担心被钓鱼而且更享受10元优惠。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;估计大多数老外觉着这个命题就如“怎么吸气?”一样无从回答吧！但在咱这儿，这是门手艺！&lt;br&gt;不让访问&lt;code&gt;推&lt;/code&gt;，不让访问&lt;code&gt;非死不可&lt;/code&gt;都无所谓了；虽然不让用Gmail有点别扭咱也忍啦！但实在受不了熊厂搜索&lt;code&gt;L1 Cache&lt;/
      
    
    </summary>
    
      <category term="Tools" scheme="http://blog.beanmr.com/categories/Tools/"/>
    
    
      <category term="VPN" scheme="http://blog.beanmr.com/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>[算法]检查元素存在于集合-Bloom Filter/Counting Bloom Filter算法简介</title>
    <link href="http://blog.beanmr.com/2015-1-08-CheckExisting-BloomFilter/"/>
    <id>http://blog.beanmr.com/2015-1-08-CheckExisting-BloomFilter/</id>
    <published>2015-01-07T16:00:00.000Z</published>
    <updated>2019-03-21T03:31:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>判断某个元素是否在集合中是开发中常见的一个问题。如果数据集合比较小常用的查找、遍历，数据库查询等方式还可用，但是在缓存是否命中这种效率敏感的高频调用或者爬虫目标URL判重、大流量活动参与者判重等海量元素或高度并发场景（对误判有一定容忍）这种方式也许就不再可接受。</p><h1 id="Bloom-Filter算法"><a href="#Bloom-Filter算法" class="headerlink" title="Bloom Filter算法"></a>Bloom Filter算法</h1><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><h2 id="误报及误报率"><a href="#误报及误报率" class="headerlink" title="误报及误报率"></a>误报及误报率</h2><h3 id="最优的哈希函数个数"><a href="#最优的哈希函数个数" class="headerlink" title="最优的哈希函数个数"></a>最优的哈希函数个数</h3><h3 id="位数组个数"><a href="#位数组个数" class="headerlink" title="位数组个数"></a>位数组个数</h3><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><h1 id="扩展及应用"><a href="#扩展及应用" class="headerlink" title="扩展及应用"></a>扩展及应用</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;判断某个元素是否在集合中是开发中常见的一个问题。如果数据集合比较小常用的查找、遍历，数据库查询等方式还可用，但是在缓存是否命中这种效率敏感的高频调用或者爬虫目标URL判重、大流量活动参与者判重等海量元素或高度并发场景（对误判有一定容忍）这种方式也许就不再可接受。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://blog.beanmr.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://blog.beanmr.com/tags/Algorithm/"/>
    
      <category term="CheckExisting" scheme="http://blog.beanmr.com/tags/CheckExisting/"/>
    
      <category term="BloomFilter" scheme="http://blog.beanmr.com/tags/BloomFilter/"/>
    
  </entry>
  
  <entry>
    <title>[实践]使用JarJar优雅的发布依赖包</title>
    <link href="http://blog.beanmr.com/2015-1-08-Export-Jar-Gracefully/"/>
    <id>http://blog.beanmr.com/2015-1-08-Export-Jar-Gracefully/</id>
    <published>2015-01-07T16:00:00.000Z</published>
    <updated>2019-03-21T06:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为服务需求方每次在项目中添加一个依赖都提心吊胆，怕新依赖会引入Jar包冲突、ClassNotFound问题。甚至有时新依赖使用的第三方包与项目中已有的版本完全不兼容，这就迫使需求方或冲突方不得不重新修改项目。因此如何为使用者发布一个第三方依赖尽可能少的包，体现了一个服务提供者的友好态度。</p><h2 id="使用JarJar重封装减少发布包的依赖"><a href="#使用JarJar重封装减少发布包的依赖" class="headerlink" title="使用JarJar重封装减少发布包的依赖"></a>使用JarJar重封装减少发布包的依赖</h2><p>Spring框架体积庞大、功能繁杂但是它的第三方依赖仅仅只有<code>Commons Log</code>这是如何做到的呢？</p><p>其实在Spring的实现中也大量了使用<code>cglib</code>，<code>asm</code>等工具包，但是 Spring 并没有直接引入依赖，而是采用将某个版本的 Jar 重新打包到自己的 package 之下的方式引入依赖。这相当于将工具包的代码拷贝到自己的项目中，使工具包里面所有类的包名都在自己的命名空间之下，从而避免了自己和其它依赖共同工具包项目之间的冲突。如果真的通过拷贝源文件实现重新发包，恐怕这个修改会非常繁琐而且容易出错。</p><p>通过 Spring 的 API 文档可以清楚的看到这一点：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2015-1-08-Export-Jar-Gracefully-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Spring使用了 <a href="https://github.com/shevek/jarjar" target="_blank" rel="noopener">Jar Jar Links</a> 实现这个功能。</p><p>build.gradle<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">task cglibRepackJar(<span class="string">type:</span> Jar) &#123; repackJar -&gt;</span><br><span class="line">  repackJar.baseName = <span class="string">"spring-cglib-repack"</span></span><br><span class="line">  repackJar.version = cglibVersion</span><br><span class="line"></span><br><span class="line">  doLast() &#123;</span><br><span class="line">    project.ant &#123;</span><br><span class="line">      taskdef <span class="string">name:</span> <span class="string">"jarjar"</span>, <span class="string">classname:</span> <span class="string">"com.tonicsystems.jarjar.JarJarTask"</span>,</span><br><span class="line"><span class="symbol">        classpath:</span> configurations.jarjar.asPath</span><br><span class="line">      jarjar(<span class="string">destfile:</span> repackJar.archivePath) &#123;</span><br><span class="line">        configurations.cglib.each &#123; originalJar -&gt;</span><br><span class="line">          zipfileset(<span class="string">src:</span> originalJar)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// repackage net.sf.cglib =&gt; org.springframework.cglib</span></span><br><span class="line">        rule(<span class="string">pattern:</span> <span class="string">"net.sf.cglib.**"</span>, <span class="string">result:</span> <span class="string">"org.springframework.cglib.@1"</span>)</span><br><span class="line">        <span class="comment">// as mentioned above, transform cglib"s internal asm dependencies from</span></span><br><span class="line">        <span class="comment">// org.objectweb.asm =&gt; org.springframework.asm. Doing this counts on the</span></span><br><span class="line">        <span class="comment">// the fact that Spring and cglib depend on the same version of asm!</span></span><br><span class="line">        rule(<span class="string">pattern:</span> <span class="string">"org.objectweb.asm.**"</span>, <span class="string">result:</span> <span class="string">"org.springframework.asm.@1"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="JarJar介绍"><a href="#JarJar介绍" class="headerlink" title="JarJar介绍"></a>JarJar介绍</h2><p><code>JarJarLinks</code>可以很方便的重新打包并封装到自己的发布中，这样做有两大好处：</p><ul><li>便捷的创建一个无依赖的单一文件的发布</li><li>避免自身对特定版本包的依赖造成的与其它程序冲突</li></ul><p><code>JarJar</code>包含一个继承于内建<code>jar</code>任务的<code>Ant Task</code>完成代码正常的打包工作，通过<code>zipfileset</code>元素指定内嵌的jar 文件，另外添加了一个新的规则配置用来描述内嵌 jar 文件的重命名规则。JarJar使用<code>ASM</code>进行<code>bytecode</code>转换方式来实现变更<code>reference</code>操作，并且提供一个特殊的<code>handling</code>来迁移资源文件和进行字符串字面量的转换工作。</p><h2 id="JarJar应用示例"><a href="#JarJar应用示例" class="headerlink" title="JarJar应用示例"></a>JarJar应用示例</h2><h3 id="基于Ant使用JarJar"><a href="#基于Ant使用JarJar" class="headerlink" title="基于Ant使用JarJar"></a>基于Ant使用JarJar</h3><p>一般情况下我们在<code>Ant</code>会引入如下的<code>task</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"jar"</span> <span class="attr">depends</span>=<span class="string">"compile"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jar</span> <span class="attr">jarfile</span>=<span class="string">"dist/example.jar"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"build/main"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>使用<code>JarJarLinks</code>我们可以使用以下配置代替上面功能，因为<code>jarjar</code> <code>task</code>本身继承于内建的<code>jar</code>任务。通过fileset指定的<code>class</code>文件可以被打包起来，如果仅仅将其它项目的<code>class</code>文件内嵌到自己的项目中并不能解决<code>Jar Hell</code>问题，因为此时类文件依旧保持着原有的名字。<br>我们可以通过 zipfileset 指定将其它项目的文件包含到自己的项目发布中，为了描述重命名的需求<code>JarJar</code>提供了一个Pattern配置来实现。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"jar"</span> <span class="attr">depends</span>=<span class="string">"compile"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">taskdef</span> <span class="attr">name</span>=<span class="string">"jarjar"</span> <span class="attr">classname</span>=<span class="string">"com.tonicsystems.jarjar.JarJarTask"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">classpath</span>=<span class="string">"lib/jarjar.jar"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jarjar</span> <span class="attr">jarfile</span>=<span class="string">"dist/example.jar"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"build/main"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 包含一个第三方 jar 到项目中 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">zipfileset</span> <span class="attr">src</span>=<span class="string">"lib/jaxen.jar"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- JarJar 提供了一个Pattern配置用来描述重命名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rule</span> <span class="attr">pattern</span>=<span class="string">"org.jaxen.**"</span> <span class="attr">result</span>=<span class="string">"org.example.@1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jarjar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在上述的实例中我们将jaxen.jar 打包到自己的发布中，并且将以 <code>org.jaxen</code>为开头的<em>包及其子包</em>的内容重命名到<code>org.example</code>之下。Pattern 中的<code>**</code>匹配<code>任意有效包的子字符串</code>，如果匹配单一的子包可以使用<code>*</code>表示并且通过<code>.</code>来分隔。<code>@1</code>表示第一个匹配，<code>@2</code>依次排列，<code>@0</code>可以用来表示整个匹配串。(这一块该怎么解释更明白呢？看Spring的配置吧！)</p><h3 id="基于Gradle使用JarJar"><a href="#基于Gradle使用JarJar" class="headerlink" title="基于Gradle使用JarJar"></a>基于Gradle使用JarJar</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Use jarjar.repackage in place of a dependency notation.</span></span><br><span class="line">    compile jarjar.repackage &#123;</span><br><span class="line">        from <span class="string">'com.google.guava:guava:18.0'</span></span><br><span class="line"></span><br><span class="line">        classDelete <span class="string">"com.google.common.base.**"</span></span><br><span class="line"></span><br><span class="line">        classRename <span class="string">"com.google.**"</span> <span class="string">"org.private.google.@1"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于命令行使用JarJar"><a href="#基于命令行使用JarJar" class="headerlink" title="基于命令行使用JarJar"></a>基于命令行使用JarJar</h3><blockquote><p>command-line<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jarjar.jar [<span class="built_in">help</span>]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>help<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jarjar.jar strings &lt;cp&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>Dumps all string literals in classpath<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jarjar.jar find &lt;level&gt; &lt;cp1&gt; [&lt;cp2&gt;]</span><br></pre></td></tr></table></figure></p></blockquote><p>这个命令可以用来构建两个classpath 之间的依赖关系，<code>level</code>可以使<code>class</code>或者<code>jar</code>。如果不存在<code>cp2</code>，则表示使用<code>cp1</code>代替。</p><blockquote><p>转换Jar<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jarjar.jar process &lt;rulesFile&gt; &lt;inJar&gt; &lt;outJar&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>这个命令可以讲<code>inJar</code>中的内容转移到<code>outJar</code>中，<code>outJar</code>内容将全部被删除。</p><p><code>classpath</code>属性是一组冒号或者分号分隔的文件夹、jar、zip文件。rules支持<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6268383" target="_blank" rel="noopener">Mustang-style</a>通配符描述。</p><h3 id="在Maven中实现JarJar功能"><a href="#在Maven中实现JarJar功能" class="headerlink" title="在Maven中实现JarJar功能"></a>在Maven中实现JarJar功能</h3><p>Maven提供了一个 Plugin 来实现JarJar功能<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jarjar-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jarjar-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ...... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jarjar-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jarjar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>asm:asm<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>org.sonatype.sisu.inject:cglib<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>org.objectweb.asm.**<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">result</span>&gt;</span>com.google.inject.internal.asm.@1<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>net.sf.cglib.**<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">result</span>&gt;</span>com.google.inject.internal.cglib.@1<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">keep</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>com.google.inject.**<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">keep</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为服务需求方每次在项目中添加一个依赖都提心吊胆，怕新依赖会引入Jar包冲突、ClassNotFound问题。甚至有时新依赖使用的第三方包与项目中已有的版本完全不兼容，这就迫使需求方或冲突方不得不重新修改项目。因此如何为使用者发布一个第三方依赖尽可能少的包，体现了一个服务提
      
    
    </summary>
    
      <category term="Tools" scheme="http://blog.beanmr.com/categories/Tools/"/>
    
    
      <category term="JarHell" scheme="http://blog.beanmr.com/tags/JarHell/"/>
    
      <category term="Gracefully" scheme="http://blog.beanmr.com/tags/Gracefully/"/>
    
  </entry>
  
  <entry>
    <title>[JVM]深入Java对象内存布局-01-基础工具Unsafe</title>
    <link href="http://blog.beanmr.com/2015-1-06-DiveIntoJvm-ObjectMemoryLayout/"/>
    <id>http://blog.beanmr.com/2015-1-06-DiveIntoJvm-ObjectMemoryLayout/</id>
    <published>2015-01-05T16:00:00.000Z</published>
    <updated>2019-03-21T06:50:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><p>Java平台屏蔽了内存管理的细节，为开发人员提供了一个安全便捷的企业级应用的开发基础。但是在深入学习和应用Java的过程中，我们由于种种的特殊应用场景的需求又希望了解Java底层内存管理某些细节；这其中有一个问题就是Java的对象在内存到底是怎么一种存在形式。已经有很多文章从Java/JVM Specification的角度阐述了这个问题，但很少有文章从一个个实例展示这些规范的落地，从而使得很多朋友读的云里雾里。这次本文就以一个个运行于JVM中真实的Java对象实例为切入点，展示这一个个规范的落地与Hotspot虚拟机对象内存布局。</p><p>大家都知道无论任何东西，在内存中最终都是一连串的0/1的二进制字串，所以最直观的最真实的了解Java对象内存布局的方式，就是将真实的对象实例在内存中的二进制表示一位位的读出来研究与学习。但是众所周知Java为我们屏蔽了繁琐的内存管理和操作问题，所以我们第一步要考虑的问题就是如何读取JVM中的内存中想要的字节，这也是本篇博文的主要内容。为了后续关于对象内存分布的讨论，我们此次先解决以下几个问题。</p><ol><li>如何在Java环境进行JVM中的内存操作</li><li>如何获取Class对象的内存信息</li><li>如何获取一个Object对象的内存信息</li></ol><h1 id="使用Unsafe进行内存操作"><a href="#使用Unsafe进行内存操作" class="headerlink" title="使用Unsafe进行内存操作"></a>使用Unsafe进行内存操作</h1><p>Java提供了一个<code>sun.misc.Unsafe</code>类，它并不是JavaSE的一部分，它更类似于Java这一安全平台的一个后门。透过这个类我们可以实现对JVM中内存的直接操作和一些线程低层次控制功能。正如其名字表达的含义一样这一切都是<code>Unsafe</code>的，是强烈不建议在应用开发中使用的，但在一些基础的数据结构或者线程工具类中我们却常常看到它的身影。这里我们应用它主要完成<code>获取对象的起始地址</code>和<code>读取指定地址内容</code></p><h2 id="如何获取Unsafe实例"><a href="#如何获取Unsafe实例" class="headerlink" title="如何获取Unsafe实例"></a>如何获取Unsafe实例</h2><p>关注如下Unsafe中的代码：构造参数私有化；类持有一个自身实例的私有field但Getter方法被限制访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 调用native方法</span></span><br><span class="line">    registerNatives();</span><br><span class="line">    <span class="comment">// 将getUnsafe加入到Reflection的过滤列表中 这个方法不能通过反射访问</span></span><br><span class="line">    sun.reflect.Reflection.registerMethodsToFilter(Unsafe.class, <span class="string">"getUnsafe"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有的构造方法 不能通过new进行实例化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 类持有一个自身的实例 这就是我们获取此类实例的基础 通过反射窃取此实例</span></span><br><span class="line"><span class="comment">// 这种方式也是单例模式等限制实例化的常用手段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe = <span class="keyword">new</span> Unsafe();</span><br><span class="line"></span><br><span class="line"> <span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断此方法的调用方有系统权限 基于调用者的类加载为null确定的</span></span><br><span class="line">    <span class="comment">// 也就是只有被系统加载器加载类能访问 非受信代码调用会出现SecurityException</span></span><br><span class="line">    <span class="comment">// 这也是获取Unsafe实例的一个方案：通过一个由系统加载的工具类调用这个方法返回实例</span></span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    <span class="keyword">return</span> theUnsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Unsafe方法的简介"><a href="#Unsafe方法的简介" class="headerlink" title="Unsafe方法的简介"></a>Unsafe方法的简介</h2><h2 id="如何通过Unsafe获取对象的地址"><a href="#如何通过Unsafe获取对象的地址" class="headerlink" title="如何通过Unsafe获取对象的地址"></a>如何通过Unsafe获取对象的地址</h2><p>###获取<strong>Class对象</strong>的地址</p><p>###获取对象实例的地址</p><h1 id="读取内存中的对象"><a href="#读取内存中的对象" class="headerlink" title="读取内存中的对象"></a>读取内存中的对象</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IDEA&quot;&gt;&lt;a href=&quot;#IDEA&quot; class=&quot;headerlink&quot; title=&quot;IDEA&quot;&gt;&lt;/a&gt;IDEA&lt;/h1&gt;&lt;p&gt;Java平台屏蔽了内存管理的细节，为开发人员提供了一个安全便捷的企业级应用的开发基础。但是在深入学习和应用Java的过程中，
      
    
    </summary>
    
      <category term="JVM" scheme="http://blog.beanmr.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://blog.beanmr.com/tags/JVM/"/>
    
      <category term="MemoryLayout" scheme="http://blog.beanmr.com/tags/MemoryLayout/"/>
    
  </entry>
  
</feed>
